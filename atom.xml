<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Vonmo&#39;s Blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-10-12T02:10:53.544Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>vonmo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>表单列表项数据编辑功能</title>
    <link href="http://example.com/archives/807/"/>
    <id>http://example.com/archives/807/</id>
    <published>2023-11-20T01:42:00.000Z</published>
    <updated>2024-10-12T02:10:53.544Z</updated>
    
    <content type="html"><![CDATA[<p>日常开发过程中，会遇到对 <code>React Antd Table</code> 列表的数据进行一键编辑修改的功能，最近刚好做到这个功能，记录一下，方便后续使用参考。</p><p><code>主页面组件</code></p><pre><code class="typescript">import &#123; useEffect, useState &#125; from &quot;react&quot;;import &#123; Form, Button, Input, message &#125; from &quot;antd&quot;;import styles from &quot;./index.less&quot;;import ResizeTable from &quot;@/components/ResizeTable&quot;;import api from &quot;../../api&quot;;const ProcessTable = () =&gt; &#123;  const [edit, setEdit] = useState(false);  const [basicData, setBasicData] = useState([]);  const [craftOrderData, setCraftOrderData] = useState&lt;any&gt;(&#123;&#125;);  const [form] = Form.useForm();  // 查询按钮 进行提交搜索  const handleSearchCraftOrderSumbit = (craftOrderId: string) =&gt; &#123;    api.searchCraftOrder(craftOrderId).then((res) =&gt; &#123;      setCraftOrderData(res.data);      setBasicData(res?.data?.detail);    &#125;);  &#125;;  const onFinish = () =&gt; &#123;    const newdata = form.getFieldsValue().packageProduct;    setBasicData(newdata);    // 根据需要获取并处理对应的接口入参    const &#123; detail, ...extraValue &#125; = craftOrderData;    const params = &#123; ...extraValue, detail: newdata &#125;;    // 编辑列表项内容后，触发【保存】按钮调用接口更新列表数据    api.updateCraftOrder(params).then((res) =&gt; &#123;      if (res.code !== 200) &#123;        message.error(res.message);        return;      &#125;      message.success(&quot;更新成功&quot;);      setEdit(false);    &#125;);  &#125;;  // 需要的列表栏  const columns = [    &#123;      title: &quot;控温方式&quot;,      dataIndex: &quot;temperatureControllerMethod&quot;,      name: &quot;temperatureControllerMethod&quot;,      key: &quot;temperatureControllerMethod&quot;,      align: &quot;center&quot;,      renderType: edit ? &quot;input&quot; : &quot;text&quot;,    &#125;,    &#123;      title: &quot;设定温度&quot;,      dataIndex: &quot;settingFurnaceTemperature&quot;,      name: &quot;settingFurnaceTemperature&quot;,      key: &quot;settingFurnaceTemperature&quot;,      align: &quot;center&quot;,      renderType: edit ? &quot;input&quot; : &quot;text&quot;,    &#125;,    &#123;      title: &quot;设定时间&quot;,      dataIndex: &quot;settingDuration&quot;,      name: &quot;settingDuration&quot;,      key: &quot;settingDuration&quot;,      align: &quot;center&quot;,      renderType: edit ? &quot;input&quot; : &quot;text&quot;,    &#125;,    &#123;      title: &quot;运行时间&quot;,      dataIndex: &quot;runningDuration&quot;,      name: &quot;runningDuration&quot;,      key: &quot;runningDuration&quot;,      align: &quot;center&quot;,      renderType: edit ? &quot;input&quot; : &quot;text&quot;,    &#125;,    &#123;      title: &quot;重量&quot;,      dataIndex: &quot;weight&quot;,      name: &quot;weight&quot;,      key: &quot;weight&quot;,      align: &quot;center&quot;,      renderType: edit ? &quot;input&quot; : &quot;text&quot;,    &#125;,  ];  const ListTableForm = (props: any) =&gt; &#123;    const &#123; edit, basicData, form &#125; = props;    const rules = [&#123; required: true, message: &quot;请填充内容!&quot; &#125;];    const [cls, setCls] = useState&lt;any[]&gt;([]);    function renderType(_: any, record: any, index: any, other: any) &#123;      const &#123; renderType &#125; = other; //renderType是让编辑态的表格，继承查看态的表格      switch (renderType) &#123;        case &quot;input&quot;:          return (            &lt;Form.Item              style=&#123;&#123; marginBottom: 0 &#125;&#125;              rules=&#123;rules&#125;              name=&#123;[record.name, other.name]&#125;              fieldKey=&#123;[record.fieldKey, other.name]&#125;            &gt;              &lt;Input                defaultValue=&#123;record.Temperature&#125;                size=&#123;&quot;middle&quot;&#125;                allowClear                disabled=&#123;other.key === &quot;num&quot;&#125;              /&gt;            &lt;/Form.Item&gt;          );        case &quot;input-value&quot;:          return (            &lt;Form.Item              style=&#123;&#123; marginBottom: 0 &#125;&#125;              rules=&#123;rules&#125;              name=&#123;[record.name, other.name]&#125;              fieldKey=&#123;[record.fieldKey, other.name]&#125;            &gt;              &lt;Input defaultValue=&#123;record.value&#125; /&gt;            &lt;/Form.Item&gt;          );        case &quot;input-description&quot;:          return (            &lt;Form.Item              style=&#123;&#123; marginBottom: 0 &#125;&#125;              rules=&#123;rules&#125;              name=&#123;[record.name, other.name]&#125;              fieldKey=&#123;[record.fieldKey, other.name]&#125;            &gt;              &lt;Input defaultValue=&#123;record.description&#125; /&gt;            &lt;/Form.Item&gt;          );        case &quot;text&quot;:          return (            &lt;Form.Item              style=&#123;&#123; marginBottom: 0 &#125;&#125;              rules=&#123;rules&#125;              name=&#123;[record.name, other.name]&#125;              fieldKey=&#123;[record.fieldKey, other.name]&#125;            &gt;              &lt;span&gt;&#123;record.name&#125;&lt;/span&gt;            &lt;/Form.Item&gt;          );        case &quot;text-value&quot;:          return (            &lt;Form.Item              style=&#123;&#123; marginBottom: 0 &#125;&#125;              rules=&#123;rules&#125;              name=&#123;[record.name, other.name]&#125;              fieldKey=&#123;[record.fieldKey, other.name]&#125;            &gt;              &lt;span&gt;&#123;record.value&#125;&lt;/span&gt;            &lt;/Form.Item&gt;          );        case &quot;text-description&quot;:          return (            &lt;Form.Item              style=&#123;&#123; marginBottom: 0 &#125;&#125;              rules=&#123;rules&#125;              name=&#123;[record.name, other.name]&#125;              fieldKey=&#123;[record.fieldKey, other.name]&#125;            &gt;              &lt;span&gt;&#123;record.description&#125;&lt;/span&gt;            &lt;/Form.Item&gt;          );        default:          return (            &lt;Form.Item shouldUpdate=&#123;true&#125; style=&#123;&#123; marginBottom: 0 &#125;&#125;&gt;              &#123;(&#123; getFieldValue &#125;) =&gt; &#123;                return (getFieldValue(props.formName) || [])?.[index]?.[                  other?.name                ];              &#125;&#125;            &lt;/Form.Item&gt;          );      &#125;    &#125;    useEffect(() =&gt; &#123;      const _newProps = props.cls.map(        (item: &#123; [x: string]: any; render: any &#125;) =&gt; &#123;          const &#123; render, ...resetProps &#125; = item;          return &#123;            ...resetProps,            render: (text: any, record: any, index: any) =&gt;              renderType(text, record, index, item),          &#125;;        &#125;      );      setCls(_newProps);    &#125;, [props.cls]);    return (      &lt;&gt;        &#123;edit ? (          // 编辑态模式下，搭配 Form.List 内嵌Form表单就可以通过form拿到所有列表项修改的值          &lt;Form.List name=&#123;props.formName || &quot;tableForm&quot;&#125;&gt;            &#123;(fields) =&gt; &#123;              return (                &lt;&gt;                  &lt;Form.Item style=&#123;&#123; marginBottom: 0 &#125;&#125;&gt;                    &lt;ResizeTable                      rowClassName=&#123;() =&gt; styles.childtable&#125;                      tableHeadheight=&#123;90&#125;                      idName=&quot;tables&quot; //必传，用来获取表格高度做数据滚动检测                      title=&#123;() =&gt; &quot;表单设置&quot;&#125;                      footer=&#123;() =&gt; &#123;                        return (                          &lt;div className=&#123;styles.footers&#125;&gt;                            &lt;Button                              onClick=&#123;() =&gt; &#123;                                setEdit(false);                              &#125;&#125;                            &gt;                              取消                            &lt;/Button&gt;                            &lt;Button                              type=&quot;primary&quot;                              className=&#123;styles.primary&#125;                              onClick=&#123;onFinish&#125;                            &gt;                              保存                            &lt;/Button&gt;                          &lt;/div&gt;                        );                      &#125;&#125;                      pagination=&#123;false&#125;                      rowKey=&#123;&quot;name&quot;&#125;                      dataSource=&#123;fields&#125;                      columns=&#123;cls&#125;                    /&gt;                  &lt;/Form.Item&gt;                &lt;/&gt;              );            &#125;&#125;          &lt;/Form.List&gt;        ) : (          &lt;Form.Item style=&#123;&#123; marginBottom: 0 &#125;&#125;&gt;            &lt;ResizeTable              rowClassName=&#123;() =&gt; styles.childtable&#125;              tableHeadheight=&#123;90&#125;              idName=&quot;table&quot;              title=&#123;() =&gt; &quot;表单设置&quot;&#125;              footer=&#123;() =&gt; &#123;                return (                  &lt;Button                    onClick=&#123;() =&gt; &#123;                      setEdit(true);                      form.setFieldsValue(&#123; packageProduct: basicData &#125;);                    &#125;&#125;                  &gt;                    编辑                  &lt;/Button&gt;                );              &#125;&#125;              pagination=&#123;false&#125;              rowKey=&#123;&quot;name&quot;&#125;              dataSource=&#123;basicData&#125;              columns=&#123;columns&#125;            /&gt;          &lt;/Form.Item&gt;        )&#125;      &lt;/&gt;    );  &#125;;  useEffect(() =&gt; &#123;    // 根据参数，查询table列表数据    handleSearchCraftOrderSumbit(&quot;123&quot;);  &#125;, []);  return (    &lt;div className=&#123;styles.root&#125;&gt;      &lt;Form form=&#123;form&#125; name=&quot;basic&quot; className=&#123;styles.main&#125;&gt;        &lt;ListTableForm          hideAction=&#123;!edit&#125;          edit=&#123;edit&#125;          formName=&quot;packageProduct&quot;          fields=&#123;basicData&#125;          basicData=&#123;basicData&#125;          cls=&#123;columns&#125;          form=&#123;form&#125;        /&gt;      &lt;/Form&gt;    &lt;/div&gt;  );&#125;;export default ProcessTable;</code></pre><p>无非就是编辑态模式下，通过Form.List内嵌Form.Item表单项的方式在form中拿到所有列表修改项的值。这里页面用到了额外封装的ResizeTable组件，其实就是对Antd的Table做了层封装 使其支持resize动态平铺以及高度自控制的滚动。</p><hr><p><code>ResizeTable组件</code></p><pre><code class="typescript">import React from &quot;react&quot;;import Table from &quot;@/components/Table&quot;;import &#123; useGetResizeHeight &#125; from &quot;./hook/useGetResizeTable&quot;;import styles from &quot;./index.less&quot;;/*** 自适应高度表格* * @功能* * 1、自动占满页面剩余高度* * 2、改变浏览器窗口时自动适应剩余高度不出现外部滚动条* * @前提* *  页面自身设置的有高度，而非根据子元素撑开高度* * @使用方法* * 1、安装lodash--yarn add lodash，仅使用里面的防抖方法* * 2、在需要使用的地方导入--import ResizeTable from &#39;@/components/ResizeTable/ResizeTable&#39;* * 3、使用--&lt;ResizeTable api和antd的Table一样/&gt;* @demo* import ResizeTable from &#39;@/components/ResizeTable/ResizeTable&#39;;* * 4、tableHeadheight（表头高度）paginationHeight（分页组件高度可选） middleHeight（底部预留高度可选） **/const ResizeTable: React.FC&lt;any&gt; = (props) =&gt; &#123;  //表头高度&lt;tableHeadheight&gt; 分页组件高度(paginationHeight) 底部预留高度(middleHeight)  const &#123; tableHeadheight, paginationHeight, middleHeight, idName &#125; = props;  const [tableHeight] = useGetResizeHeight(    `$&#123;idName&#125;`,    tableHeadheight,    paginationHeight ? paginationHeight : 0,    middleHeight ? middleHeight : 0  );  let tableProps = &#123; ...props, scroll: &#123; y: tableHeight &#125; &#125;;  if (props &amp;&amp; props.scroll &amp;&amp; props.scroll.x) &#123;    tableProps.scroll.x = props.scroll.x;  &#125;  return (    &lt;div className=&#123;styles.tableWrap&#125;&gt;      &lt;div id=&#123;idName&#125; className=&#123;styles.table&#125;&gt;        &lt;Table &#123;...tableProps&#125; /&gt;      &lt;/div&gt;    &lt;/div&gt;  );&#125;;export default ResizeTable;</code></pre><hr><p><code>useGetResizeHeight动态缩放组件</code></p><pre><code class="typescript">import &#123; useEffect, useState &#125; from &quot;react&quot;;import debounce from &quot;lodash/debounce&quot;;import &#123; useSize &#125; from &quot;ahooks&quot;;export function useGetResizeHeight(  name: string,  tableHeadheight: number,  paginationHeight: number,  middleHeight: number) &#123;  //设置撑高表格外部包裹元素的高度  const [tableHeight, setTableHeight] = useState(500);  const size = useSize(document.getElementById(name));  const handleGetTableHeight = () =&gt; &#123;    setTimeout(() =&gt; &#123;      let height = document.getElementById(name)!.clientHeight;      //高度-表头高度&lt;tableHeadheight&gt;-分页组件高度(paginationHeight)-底部预留高度(middleHeight)      height = height - tableHeadheight - paginationHeight - middleHeight - 6;      setTableHeight(height);    &#125;);  &#125;;  useEffect(() =&gt; &#123;    handleGetTableHeight();    const debounced = debounce(handleGetTableHeight, 200);    window.addEventListener(&quot;resize&quot;, debounced);    return () =&gt; window.removeEventListener(&quot;resize&quot;, debounced);  &#125;, [size]);  return [tableHeight];&#125;</code></pre><p><code>Tips: </code>这里有个小点要注意下，因为这里的table表头只有一层，使用这种方式是完全没问题的。但如果是合并表头的header，columns中内嵌了children后，使用这个<code>ListTableForm</code>编辑的时候就会导致columns只能显示第一层的部分，导致表头header丢失了。<br>这个时候可以使用geek的方式进行处理</p><p><code>多表头合并态下，如何编辑的时候固定表格头不变，以下是部分实例代码 参考</code></p><pre><code class="typescript">  &#123;    edit ? (      // 编辑态      &lt;Form.List name=&#123;props.formName || &quot;tableForm&quot;&#125;&gt;        &#123;(fields) =&gt; &#123;          return (            &lt;&gt;              &lt;Form.Item style=&#123;&#123; marginBottom: 0 &#125;&#125;&gt;                &#123;/* 只展示固定表头做占位用 不展示数据 同时根据style清除原有的table-body样式 */&#125;                &lt;Table                  className=&#123;`$&#123;styles.emptyTableBody&#125;`&#125;                  pagination=&#123;false&#125;                  dataSource=&#123;[]&#125;                  columns=&#123;colums as any&#125;                /&gt;                &#123;/* 固定上面的表头后，把现在的表头通过样式藏掉，因为表单的数据需要通过column里的name做绑定 */&#125;                &lt;Table                  className=&#123;`$&#123;styles.emptyTableColumn&#125;`&#125;                  pagination=&#123;false&#125;                  rowKey=&#123;&quot;name&quot;&#125;                  footer=&#123;() =&gt; &#123;                    return (                      &lt;div className=&#123;styles.footers&#125;&gt;                        &lt;Button                          onClick=&#123;() =&gt; &#123;                            setEdit(false);                          &#125;&#125;                          style=&#123;&#123; marginRight: 15 &#125;&#125;                        &gt;                          取消                        &lt;/Button&gt;                        &lt;Button                          type=&quot;primary&quot;                          className=&#123;styles.primary&#125;                          onClick=&#123;onFinish&#125;                        &gt;                          保存                        &lt;/Button&gt;                      &lt;/div&gt;                    );                  &#125;&#125;                  dataSource=&#123;fields&#125;                  columns=&#123;cls&#125;                /&gt;              &lt;/Form.Item&gt;            &lt;/&gt;          );        &#125;&#125;      &lt;/Form.List&gt;    ) : (      // 仅展示      &lt;Form.Item style=&#123;&#123; marginBottom: 0 &#125;&#125;&gt;        &lt;Table /&gt;      &lt;/Form.Item&gt;    )  &#125;  // 上面对应的Table隐藏表头head和表格body列表内容的样式  .emptyTableBody &#123;    :global(.ant-table-tbody) &#123;      display: none;    &#125;  &#125;  .emptyTableColumn &#123;    :global(.ant-table-thead) &#123;      display: none;    &#125;  &#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;日常开发过程中，会遇到对 &lt;code&gt;React Antd Table&lt;/code&gt; 列表的数据进行一键编辑修改的功能，最近刚好做到这个功能，记录一下，方便后续使用参考。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;主页面组件&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;typ</summary>
      
    
    
    
    
    <category term="React" scheme="http://example.com/tags/React/"/>
    
    <category term="AntD" scheme="http://example.com/tags/AntD/"/>
    
  </entry>
  
  <entry>
    <title>echarts 基础属性配置单</title>
    <link href="http://example.com/archives/34379/"/>
    <id>http://example.com/archives/34379/</id>
    <published>2023-10-17T02:25:08.000Z</published>
    <updated>2024-10-12T02:10:53.543Z</updated>
    
    <content type="html"><![CDATA[<p>日常开发中，echarts 的使用率还是挺高的，但是每次使用的时候，总要去<a href="https://echarts.apache.org/zh/index.html">官网</a> 查找对应的配置表进行配置，感觉特别麻烦，所以在日常开发中，对一些常用的配置，做一些总结，方便日后在做可视化界面开发的时候，可以直接查看这些配置，提升开发效率。</p><pre><code class="javascript">const option = &#123;  // 左上角标题  title: &#123;    text: &quot;我是标题&quot;,    left: 0, // 距左侧的距离    top: 10, // 距顶部的距离    textStyle: &#123;      fontSize: 13, // 标题大小      color: &quot;#45F9F1&quot;, // 标题颜色    &#125;,  &#125;,  // 匹配多个颜色  color: [&quot;#F8E71C&quot;, &quot;#507df7&quot;, &quot;#F5A623&quot;, &quot;#47D1CB&quot;],  // 顶部快捷导航的小banner  legend: &#123;    right: 0, // 靠近最右侧显示，如果不加right 默认会居中显示    top: &quot;5px&quot;, // 距离顶部的距离    icon: &quot;rect&quot;, // 线条类型    itemWidth: 12, // 线条宽    itemHeight: 5, // 线条高    textStyle: &#123;      color: &quot;#fff&quot;, // 文字颜色    &#125;,  &#125;,  // 可视化图距上/下/左/右的距离  grid: &#123;    top: &quot;15%&quot;,    left: &quot;3%&quot;,    right: &quot;4%&quot;,    bottom: &quot;3%&quot;,    // containLabel指的是grid 区域是否包含坐标轴的刻度标签    containLabel: true,  &#125;,  // 鼠标悬浮展示的数据  tooltip: &#123;    // 鼠标hover显示自定义 (若没有额外的样式进行展示，可直接保留trigger这一个默认属性的展示即可)    trigger: &quot;axis&quot;,    axisPointer: &#123;      type: &quot;shadow&quot;, // 鼠标hover时，整块区域覆盖阴影    &#125;,    textStyle: &#123;      color: &quot;#D6D6D6&quot;, // 文字颜色    &#125;,    borderColor: &quot;rgba(0,0,0,0.8)&quot;, // 文字边框    backgroundColor: &quot;rgba(30, 37, 45, 1)&quot;, // tooltip整块背景    formatter: function (params) &#123;      // 注意：如果需要展示多个，在series中data的数据一定要是一个数组对象，且对象中必须有value的值      // data: [1,2,3] 等同于 data: [&#123;value: 1&#125;, &#123;value: 2&#125;,&#123;value: 3&#125;]      // 然后将额外的需要展示的数据放到对应的每个对象里 然后展示的时候取出来就可以了)      return (        `&lt;div style=&quot;display:inline-block;&quot;&gt;$&#123;params[0].name&#125;&lt;/div&gt;&lt;br /&gt;` +        `内容: $&#123;params[0].value&#125;%`      );    &#125;,  &#125;,  // x轴  xAxis: [    &#123;      // &#39;category&#39; 类目轴，适用于离散的类目数据，为该类型时必须通过 data 设置类目数据。      type: &quot;category&quot;,      // boundaryGap：x轴两边是否留白      boundaryGap: true,      axisLine: &#123;        // 是否隐藏x轴线        show: true,        //x轴线的颜色以及宽度以及线条类型        lineStyle: &#123;          color: &quot;#E7E7E7&quot;,          width: 0,          type: &quot;solid&quot;,        &#125;,      &#125;,      axisLabel: &#123;        show: true,        //x轴文字的配置        textStyle: &#123;          color: &quot;#fff&quot;,        &#125;,      &#125;,      axisTick: &#123;        show: false, //隐藏x轴刻度      &#125;,      axisPointer: &#123;        // type: &quot;none&quot;, // 取消当前轴的坐标轴指示器        lineStyle: &#123;          color: &quot;#ccc&quot;, // 分割线颜色          width: 1, // 分割线现宽          opacity: 0.1, // 图形透明度        &#125;,      &#125;,      data: [], // x轴的数据    &#125;,  ],  // y轴  yAxis: [    &#123;      // &#39;value&#39; 数值轴，适用于连续数据      type: &quot;value&quot;,      axisLine: &#123;        show: true,        //y轴线的颜色以及宽度        lineStyle: &#123;          color: &quot;#E7E7E7&quot;,          width: 0,          type: &quot;solid&quot;,        &#125;,      &#125;,      splitLine: &#123;        // 修改背景线条样式        show: true, // 是否展示        lineStyle: &#123;          type: &quot;solid&quot;, // 分割线类型          color: &quot;#ccc&quot;, // 分割线颜色          width: 1, // 分割线现宽          opacity: 0.1, // 图形透明度        &#125;,      &#125;,      // 正常情况下，是不需要设置（min、max）这两个值的，因为其会通过series中的data中的值自动进行计算最小值和最大值      max: 100, // Y轴最大数值      min: 0, // Y轴最小数值    &#125;,  ],  series: [    &#123;      smooth: true, // 折线图是否是圆滑曲线 平滑显示      symbol: &quot;circle&quot;, //每个小点点的样式风格      showSymbol: false, //默认不展示小点点 经过再显示      name: &quot;当月&quot;,      type: &quot;line&quot;,      stack: &quot;Total&quot;,      // itemStyle: &#123;      //   // itemStyle属性不写，会取默认颜色作为填充（正常情况下都是默认的）如有需要定制化的，可以打开此项进行相应的配置      //   normal: &#123;      //     color: &quot;#F21612&quot;, //轨迹线和小点点的颜色      //     borderColor: &quot;#F21612&quot;, //小点点的边框颜色      //   &#125;,      // &#125;,      // lineStyle: &#123;      //  // lineStyle属性不写，会取默认颜色作为填充（正常情况下都是默认的）如有需要定制化的，可以打开此项进行相应的配置      //   normal: &#123;      //     width: 1, //连线粗细      //     color: &quot;#F21612&quot;, //轨迹线颜色      //   &#125;,      // &#125;,      // 如果是折线图、圆滑曲线，曲线下方的阴影区域(areaStyle)设置浅色      areaStyle: &#123;        color: &quot;#507df7&quot;, // 曲线下方阴影的颜色        opacity: 0.2, // 曲线下方阴影的透明度        origin: &quot;start&quot;,        // 这里既可以通过上面的color和opacity进行展示，如果需要渐变色处理 也可以直接在color属性上绑定渐变色处理即可（仅保留color一项即可）        // color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [        //   &#123;        //     offset: 0,        //     color: &quot;rgba(243, 78, 98, 0.8)&quot;,        //   &#125;,        //   &#123;        //     offset: 1,        //     color: &quot;rgba(255, 255, 255, 0)&quot;,        //   &#125;,        // ]),      &#125;,      emphasis: &#123;        focus: &quot;series&quot;,      &#125;,      data: [120, 132, 101, 134, 90, 230, 210],    &#125;,  ],&#125;;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;日常开发中，echarts 的使用率还是挺高的，但是每次使用的时候，总要去&lt;a href=&quot;https://echarts.apache.org/zh/index.html&quot;&gt;官网&lt;/a&gt; 查找对应的配置表进行配置，感觉特别麻烦，所以在日常开发中，对一些常用的配置，做一些总</summary>
      
    
    
    
    
    <category term="echarts" scheme="http://example.com/tags/echarts/"/>
    
  </entry>
  
  <entry>
    <title>基于等比例缩放的大屏可视化自适应方案实现</title>
    <link href="http://example.com/archives/1711/"/>
    <id>http://example.com/archives/1711/</id>
    <published>2023-05-26T06:50:27.000Z</published>
    <updated>2024-10-12T02:10:53.544Z</updated>
    
    <content type="html"><![CDATA[<h1 id="可视化-1-0版本"><a href="#可视化-1-0版本" class="headerlink" title="可视化 1.0版本"></a>可视化 1.0版本</h1><p>前端的数据可视化越来越重要，炫酷大屏的需求越来越多，您是否经常为屏幕不能自适应而烦恼？如何高度还原设计稿？如何在多种终端都呈现完美效果？</p><p>当屏幕宽高比例小于设计稿时，按设计稿比例沿水平方向铺满屏幕。当屏幕宽高比大于设计稿时，按设计稿比例沿垂直方向铺满屏幕。用等比缩放的方式，不论屏幕多大，分辨率是什么，都能呈现完美效果。</p><p>最终想要实现的效果类似此种：<a href="https://sugar.aipage.com/dataPortalShare/SugarBI?menu=m_l4dxdax22rvvs">https://sugar.aipage.com/dataPortalShare/SugarBI?menu=m_l4dxdax22rvvs</a></p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>根据 UI 提供的设计稿，定义页面长宽基准值（如：w-1920 * h-969）基于此长宽比，进行等比例放大缩小，垂直居中显示。定义了页面基准值后，这时候我需要用到页面视口长宽，这里我用的是 document.documentElement.clientWidth 和 document.documentElement.clientHeight 来获取<br><img src="https://developer.mozilla.org/en-US/docs/Web/API/Element/clientWidth/dimensions-client.png"><br>然后基于页面视口的长宽和 UI 设计稿的基准长宽做对比，就可以算出页面缩放了多少，视口的长宽去掉缩放后的基准长宽剩下的值就是页面空白的区域（空白区域填充默认底色），然后去除一半值后，就可以实现居中的效果了。</p><h2 id="基于-transform-的等比例缩放自适应方案"><a href="#基于-transform-的等比例缩放自适应方案" class="headerlink" title="基于 transform 的等比例缩放自适应方案"></a>基于 transform 的等比例缩放自适应方案</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform">mdn transform</a> 是什么，CSS transform 属性允许你旋转，缩放，倾斜或平移给定元素，这是通过修改 CSS 视觉格式化模型的坐标空间来实现的。</p><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p><img src="https://cdn.jsdelivr.net/gh/alileew/alileew_images/img/20230531112848.gif"></p><figcaption>git-20230531112848.gif</figcaption><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><pre><code class="javascript">父组件&lt;template&gt;  &lt;div class=&quot;app-content&quot;&gt;    &lt;ScreenAdapter&gt;      这里是大屏的具体页面    &lt;/ScreenAdapter&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style lang=&quot;scss&quot; scoped&gt;// 用来填充大屏超出的底色部分.app-content &#123;  background-color: #1c1d20;  width: 100%;  height: 100%;&#125;&lt;/style&gt;</code></pre><pre><code class="javascript">子组件（ScreenAdapter）&lt;template&gt;  &lt;div class=&quot;screen-adapter&quot; :style=&quot;style&quot;&gt;    // slot 会把大屏的页面传递过来，这样的话 只需要关注自己的页面    // 等比例伸缩的逻辑就不用管 交给 ScreenAdapter 就可以了    &lt;slot /&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; debounce &#125; from &quot;lodash&quot;;export default &#123;  props: &#123;    width: &#123;      type: String,      default: &quot;1920&quot;,    &#125;,    height: &#123;      type: String,      default: &quot;969&quot;,    &#125;,  &#125;,  data() &#123;    return &#123;      style: &#123;        width: this.width + &quot;px&quot;,        height: this.height + &quot;px&quot;,        transform: &quot;scale(1)&quot;,        margin: &quot;0&quot;      &#125;,      // 判断缩放的是 X轴 还是 Y轴 就可以将空出来的区域通过 margin 来区分是水平还是垂直方向上的居中      isXaxis: true,    &#125;;  &#125;,  mounted() &#123;    this.setScale();    window.onresize = debounce(this.setScale, 300);  &#125;,  methods: &#123;    // 获取放大缩小比例    getScale() &#123;      const w = document.documentElement.clientWidth / this.width;      const h = document.documentElement.clientHeight / this.height;      this.isXaxis = w &lt; h ? false : true;      return w &lt; h ? w : h;    &#125;,    // 设置比例    setScale() &#123;      this.style.transform = &quot;scale(&quot; + this.getScale() + &quot;)&quot;;      const widthScale = this.width * this.getScale();      const heightScale = this.height * this.getScale();      const xxWidth = (document.documentElement.clientWidth - widthScale) / 2;      const yyHeight =        (document.documentElement.clientHeight - heightScale) / 2      const xAxixMargin = this.isXaxis ? xxWidth : 0;      const yAxixMargin = !this.isXaxis ? yyHeight : 0;      this.style.marginLeft =  xAxixMargin + &#39;px&#39;;      this.style.marginRight =  xAxixMargin + &#39;px&#39;;      this.style.marginTop = yAxixMargin + &#39;px&#39;;      this.style.marginBottom = yAxixMargin + &#39;px&#39;;    &#125;,  &#125;,&#125;;&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.screen-adapter &#123;  transform-origin: 0 0;  position: absolute;  left: 0;  top: 0;  transition: 0.3s;  background: #1c1d20;&#125;&lt;/style&gt;</code></pre><hr><h1 id="可视化-2-0版本"><a href="#可视化-2-0版本" class="headerlink" title="可视化 2.0版本"></a>可视化 2.0版本</h1><p>在1.0的基础上进行了动态缩放组件的改进，通过对当前屏幕伸缩的宽高、以及设计稿的宽高进行独立的计算，得出各自的伸缩比，而不是通过1.0版本中视口的宽高对比设计稿的宽高进行对比得到对应的伸缩比。</p><p>升级的2.0版本除了计算方式上做了调整，另外语法上也升级了对vue3的兼容（上面1.0版本是vue2的语法），适配vue3项目的语法。</p><pre><code class="javascript">&lt;template&gt;  &lt;div class=&quot;screen-adapter&quot; :style=&quot;style&quot;&gt;    &lt;slot /&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ref, onMounted &#125; from &quot;vue&quot;;import &#123; debounce &#125; from &quot;lodash&quot;;// 初始设计稿宽高const designWidth = &quot;1920&quot;;const designHeight = &quot;969&quot;;const style = ref(&#123;  width: designWidth + &quot;px&quot;,  height: designHeight + &quot;px&quot;,  transform: &quot;scale(1)&quot;,  margin: &quot;0&quot;,&#125;);// 获取缩放比const getScale = () =&gt; &#123;  // 获取对应的宽高比  const screenRatio =    document.documentElement.clientWidth /    document.documentElement.clientHeight;  const designRatio = designWidth / designHeight;  return &#123;    // x轴是否缩放满屏，此时y方向需要居中    xFit: screenRatio &lt; designRatio,    // 取小的缩放比    scale:      screenRatio &lt; designRatio        ? document.documentElement.clientWidth / designWidth        : document.documentElement.clientHeight / designHeight,  &#125;;&#125;;// 大屏自适应函数const setScale = () =&gt; &#123;  const &#123; xFit, scale &#125; = getScale();  const adjustedWidth = designWidth * scale;  const adjustedHeight = designHeight * scale;  // 没有铺满的一侧 进行居中  const marginWidth = document.documentElement.clientWidth - adjustedWidth;  const marginHeight = document.documentElement.clientHeight - adjustedHeight;  const xMargin = xFit ? 0 : marginWidth / 2; // 左右居中  const yMargin = xFit ? marginHeight / 2 : 0; // 上下居中  style.value.transform = `scale($&#123;scale&#125;)`;  style.value.marginLeft = xMargin + &quot;px&quot;;  style.value.marginRight = xMargin + &quot;px&quot;;  style.value.marginTop = yMargin + &quot;px&quot;;  style.value.marginBottom = yMargin + &quot;px&quot;;&#125;;onMounted(() =&gt; &#123;  setScale();  window.onresize = debounce(setScale, 300);&#125;);&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.screen-adapter &#123;  transform-origin: 0 0;  position: absolute;  left: 0;  top: 0;  transition: 0.3s;  background: #00142d;&#125;&lt;/style&gt;具体使用的话不变，引入组件，将内部包裹的页面通过slot插槽的方式进行处理即可。</code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>基于transform缩放的方案，优点是按设计稿设置元素大小，无需转换长度单位。页面会根据页面设置的基准值和视口的长宽比做等比例的缩放且居中，以此达到适配大屏展示的效果。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;可视化-1-0版本&quot;&gt;&lt;a href=&quot;#可视化-1-0版本&quot; class=&quot;headerlink&quot; title=&quot;可视化 1.0版本&quot;&gt;&lt;/a&gt;可视化 1.0版本&lt;/h1&gt;&lt;p&gt;前端的数据可视化越来越重要，炫酷大屏的需求越来越多，您是否经常为屏幕不能自适应而烦恼</summary>
      
    
    
    
    
    <category term="vue" scheme="http://example.com/tags/vue/"/>
    
    <category term="大屏可视化" scheme="http://example.com/tags/%E5%A4%A7%E5%B1%8F%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>浅述垃圾回收机制</title>
    <link href="http://example.com/archives/2616/"/>
    <id>http://example.com/archives/2616/</id>
    <published>2022-08-21T06:04:44.000Z</published>
    <updated>2024-10-12T02:10:53.545Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>JS会在创建变量时自动分配内存，在不使用的时候会自动周期性的释放内存，释放的过程就叫 “垃圾回收”。</p><h2 id="垃圾如何产生"><a href="#垃圾如何产生" class="headerlink" title="垃圾如何产生"></a>垃圾如何产生</h2><p>我们在写代码时会创建一个基本类型、对象、函数……这些都是需要占用内存的，但是我们并不关注这些，因为这是引擎为我们分配的，我们不需要显式手动的去分配内存。但如果内存分配之后又没有及时的回收，就会导致内存泄漏，也就是内存垃圾的产生。<br>程序的运行需要内存，只要程序提出要求，操作系统或者运行时就必须提供内存，那么对于持续运行的服务进程，必须要及时释放内存，否则，内存占用越来越高，轻则影响系统性能，重则就会导致进程崩溃。</p><h2 id="垃圾回收策略"><a href="#垃圾回收策略" class="headerlink" title="垃圾回收策略"></a>垃圾回收策略</h2><p>垃圾回收策略主要分两种，一是<code>引用计数</code>，二是<code>分代回收</code>（V8垃圾回收策略主要基于 分代式垃圾回收机制）</p><p><strong>引用计数（Reference Counting）</strong>：这个策略是比较早的一种垃圾回收算法，它把 对象是否不再需要，简化定义为 对象有没有其他对象引用到它，如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。<br>但引用计数有个缺点就是 <code>循环引用不能为0</code>，举个例子：</p><pre><code>const a = 1; b = a; c = a; 变量被多次引用，就会导致引用计数失效，也就是说循环引用不可能为0。两个都互相引用了，引用计数不为0，所以两个变量都无法回收。如果频繁的调用改函数，则会造成很严重的内存泄漏。</code></pre><p><strong>分代回收</strong>：V8 的垃圾回收策略主要基于分代式垃圾回收机制，V8 中将堆内存分为新生代和老生代两区域，采用不同的垃圾回收器也就是不同的策略管理垃圾回收。</p><ul><li><p>新生代 <code>Scavenge 算法</code> 存放生命周期短的对象</p><ul><li><p>from(内存区域也就是被使用的区域)/to，扫描 ⇒ 存活对象copy到to, 16M</p></li><li><p>新生代使用 <code>Scavenge</code> 算法实现 <code>GC</code>,它将 新生代分为两个半区域，分别成为 <code>from空间和to空间</code> 一次垃圾回收 ♻️ 分为两步：</p><ol><li>将 from 空间的活对象（从 roor 可以访问到）复制到 to</li><li>切换 from、to 角色</li></ol><p><strong>如何回收新生代对象？</strong><br>检查<code>From</code>空间内的存活对象，若对象存活，检查对象是否符合晋升条件，若符合条件则晋升到老生代，否则将对象从 <code>From</code> 空间复制到 <code>To</code> 空间。若对象不存活，则释放不存活对象的空间。完成复制后，将 <code>From</code> 空间与 <code>To</code> 空间进行角色翻转。</p><p><strong>如何进行对象晋升机制？</strong><br>一轮<code>GC</code>还存活的新生代需要晋升。当对象从<code>From</code> 空间复制到 <code>To</code> 空间时，若 <code>To</code> 空间使用超过 25%，则对象直接晋升到老生代中。设置为25%的比例的原因是，当完成 <code>Scavenge</code> 回收后，<code>To</code> 空间将翻转成<code>From</code> 空间，继续进行对象内存的分配。若占比过大，将影响后续内存分配。<br><img src="https://cdn.jsdelivr.net/gh/alileew/alileew_images/img/202209041934460.png"></p><figcaption>分代回收-202209041934460.png</figcaption></li></ul></li><li><p>老生代 <code>标记-清除算法</code> 存放生命周期长的对象</p><ul><li><p>老生代使用标记-<code>标记-清除算法</code></p><ul><li>对老生代进行第一遍扫描，<code>标记</code>存活的对象</li><li>对老生代进行第二遍扫描，<code>清除</code>未被标记的对象 ⇒ 碎片化问题<ul><li>[1,2,3,4,5,6] ⇒ 2/4 ⇒ [1,3,5,6]</li></ul></li><li>将存活对象往内存的一端<code>移动</code></li><li>清除掉存活对象边界外的内存（<code>压缩</code>）</li></ul></li><li><p>标记-清除是一种停下应用程序的技术，增量标记 - 提升标记性能</p><ul><li><p>标记-清除需要<strong>停下应用程序</strong>，但老生代对象多，工作量大，所以v8使用<code>增量标记</code>的方式，防止停止时间过久；</p></li><li><p>何谓<code>增量标记</code><br>为了解决全停顿的现象，2011年V8推出了增量标记；<br>简单理解·增量标记：V8将标记过程分为一个个的子标记过程，同时让垃圾回收标记和JS应用逻辑交替进行，直至标记完成。</p><p>深入理解·增量标记：为了降低全堆垃圾回收带来的停顿时间,V8先从标记阶段入手,将原本要一口气停顿完成的动作改为增量标记(incremental marking),也就是拆分为许多小“步进”,每做完一“步进” 就让 JavaScript 应用逻辑执行一小会儿,垃圾回收与应用逻辑交替执行直到标记阶段完成<br><img src="https://cdn.jsdelivr.net/gh/alileew/alileew_images/img/202209041935394.png"></p><figcaption>清除算法-202209041935394.png</figcaption></li></ul></li></ul></li></ul><p><strong>延展：Scavenge算法</strong><br>Scavenge 主要采用了 <strong>Cheney算法</strong>，Cheney算法新生代空间的堆内存分为2块同样大小的空间，称为 Semi space，处于使用状态的成为 From空间 ，闲置的称为 To 空间。垃圾回收过程如下：</p><ol><li>检查From空间，如果From空间被分配满了，则执行Scavenge算法进行垃圾回收</li><li>如果未分配满，则检查From空间是否有存活对象，如果无存活对象，则直接释放未存活对象的空间</li><li>如果存活，将检查对象是否符合晋升条件，如果符合晋升条件，则移入老生代空间，否则将对象复制进To空间</li><li>完成复制后将From和To空间角色互换，然后再从第一步开始执行</li></ol><p><strong>参考：</strong></p><ol><li><a href="https://mp.weixin.qq.com/s/uxSoXkmi5KIGNPsyd5cXrA">浅谈JS内存机制</a></li><li><a href="https://v8.dev/blog/trash-talk">Trash talk: the Orinoco garbage collector</a></li><li><a href="https://segmentfault.com/a/1190000038175558">一起来看Javascript的垃圾回收机制</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;JS会在创建变量时自动分配内存，在不使用的时候会自动周期性的释放内存，释放的过程就叫 “垃圾回收”。&lt;/p&gt;
&lt;h2 id=&quot;垃圾如何产生&quot;</summary>
      
    
    
    
    
    <category term="垃圾回收" scheme="http://example.com/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
  </entry>
  
  <entry>
    <title>从HTTP/1到HTTP/3</title>
    <link href="http://example.com/archives/22388/"/>
    <id>http://example.com/archives/22388/</id>
    <published>2022-06-18T12:48:17.000Z</published>
    <updated>2024-10-12T02:10:53.544Z</updated>
    
    <content type="html"><![CDATA[<p>HTTP(Hyper Text Transfer Protocol-超文本传输协议)是一个简单的请求-响应协议，它通常运行在<a href="https://baike.baidu.com/item/TCP/33012">TCP</a>之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。</p><h2 id="HTTP1-0"><a href="#HTTP1-0" class="headerlink" title="HTTP1.0"></a>HTTP1.0</h2><p>规定浏览器和服务器保持短暂的连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接，服务器处理完成后立即断开 TCP 连接。</p><h2 id="HTTP1-0-缺点"><a href="#HTTP1-0-缺点" class="headerlink" title="HTTP1.0 缺点"></a>HTTP1.0 缺点</h2><ul><li>无法复用连接，每次发送请求，都需要进行一次 TCP 连接，而 TCP 的连接释放过程又是比较费事的。这种无连接的特性会使得网络的利用率变低。<ul><li>一次只能连接一个请求，请求响应完毕，才能响应下一个请求</li></ul></li><li>不支持断点续传，也就是说，每次都会传送全部的页面和数据（一旦中途中断，必须重新开始上传）</li></ul><hr><h2 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h2><p>HTTP1.1 继承了 HTTP1.0 的 TCP 连接，对其存在的一些问题做了更多的改善</p><ul><li><p>持久连接(keep-alive)也称 “长连接”</p><ul><li><p>保持 HTTP 连接不断开，避免了每次客户端与服务器请求都要重复建立释放建立 TCP 连接，提高了网络的利用率。如果客户端想关闭 HTTP 连接，可以在请求头中携带 Connection: false 来告知服务器关闭请求。</p></li><li><p><code>http1.1</code> 中浏览器客户端在<code>同一时间</code>，针对<code>同一域名</code>下的请求<code>有一定数量的限制</code>，超过此数量请求会被阻塞</p><blockquote><p>问题：为什么HTTP1.x版本要限制并发请求数？<br>  个人理解：计算机资源是有限的，每一个 tcp 连接都会占用资源，且有线程（libuv）切换成本，不可能无限制的创建tcp连接</p><pre><code>- 占用资源：端口是有限的（每个tcp都会限制一个端口）、内核内存、文件描述符、内核文件打开数、数据接收/缓冲区、线程- 对服务端和客户端来说，tcp连接都是很贵的- H1.0之后，引入 **keep-alive** 就是为了复用tcp连接(这里的引用不是说H1.0之后才出现，其实H1.0已经有了 keep-alive 只是默认不开启)，因为大多数情况下，复用已有连接会比创建（三次握手耗时）一个新的链接性能高很多- 服务端需要防御ddos攻击，所以会限制同一个ip过来的连接数</code></pre></blockquote></li></ul></li><li><p>HTTP 管道化</p><ul><li>多个请求可以同时发送，但是服务器还是按照顺序进行回应（abcd ⇒ abcd 一旦 a 被阻塞，后面的请求都要排队等着，其实就是队列【先进先出】的思想）这就造成了队头阻塞的问题</li></ul></li><li><p>分块编码传输</p></li><li><p>新增 Host 头处理</p></li><li><p>更多缓存处理</p><ul><li>H1.0 主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准</li><li>H1.1 Etag、If-None-Match、cache-control 等更多可供选择的缓存头来控制缓存策略(可参考之前写的强缓存和协商缓存文章<a href="/archives/60150/">聊聊浏览器的缓存策略</a>)</li></ul></li><li><p>新增更多状态码</p><ul><li>新增了 24 个错误状态响应码，如 409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li></ul></li><li><p>断点续传、并行下载</p><ul><li>通过使用请求头中的 Range 来实现</li></ul></li></ul><h2 id="HTTP1-1-缺点"><a href="#HTTP1-1-缺点" class="headerlink" title="HTTP1.1 缺点"></a>HTTP1.1 缺点</h2><ul><li>队头阻塞（Head-of-line blocking）<ul><li>当单个（慢）对象阻止后续对象前进时，即队头阻塞。类比队列，先进先出，一旦有一个阻塞了后续的都会受到影响</li></ul></li><li>头部冗余</li><li>TCP 连接数限制<ul><li>一个 TCP 连接最多只能派发固定的请求数量（chrome 是 6 个）</li></ul></li><li>TCP 慢启动<ul><li>TCP 慢启动是 TCP 拥塞控制的一种策略。TCP 在刚建立连接完成后，首先是有个慢启动的过程，这个慢启动的意思就是一点一点的提高发送数据包的数量。当发送方每收到一个 确认包，拥塞窗口的大小就会加 1。说慢启动会带来性能问题就是因为如果请求一个不大的页面关键资源也要经过这样的慢启动过程，那么页面的渲染性能就会大大的降低。</li><li>解决：<ul><li>慢开始，拥塞避免</li><li>快重传，快恢复</li></ul></li></ul></li></ul><hr><h2 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h2><p>HTTP2.0 在 HTTP1.1 的基础上，对其存在的一些问题做了更多的改善</p><ul><li><p>强制开启 TLS</p><ul><li>TCP + TLS（SSL）</li></ul></li><li><p>二进制分帧</p><ul><li>原本是一整块信息一次性下发，http1.0 是基于文本格式，分帧后先在<code>发送方拆分成更小的包</code>，并以二进制的方式进行编码传输，然后<code>在接受方重组</code></li><li>串行通讯 ⇒ 多路复用（关于此点，其实还可以聊聊 <code>H1.1</code> 的管道通讯机制）<ul><li>管道通讯：多个请求同时发送给服务端（缺点会按照发送顺序来返回对应的请求数据）</li></ul></li><li>HTTP2 会将所有传输的信息分割为更小的消息和帧（frame）并对它们采用二进制格式的编码，这种负责拆分、组装请求和二进制帧的一层就叫做<strong>二进制分帧</strong><ul><li>拆解成多个包异地恢复</li><li>数据给到下层协议之前将数据“打散”成更小的帧，并以 2 进制方式进行编码传输</li></ul></li></ul></li><li><p>多路复用</p><ul><li><p>HTTP1.1 如果要同时发起多个请求，就得建立多个 TCP 连接，因为一个 TCP 连接同时只能处理一个请求，在 HTTP2 上，多个请求可以共用一个 TCP 连接，这称为“多路复用”。同一个请求和响应用一个流来表示，并有唯一的流 ID 来标识。多个请求和响应在 TCP 连接中可以乱序发送，到达目的地后再通过流 ID 重新组建。</p></li><li><p>HTTP/1.1 协议的请求-响应模型大家都是熟悉的，我们用“HTTP 消息”来表示一个请求-响应的过程，那么 HTTP/1.1 中的消息是“管道串形化”的：只有等一个消息完成之后，才能进行下一条消息；而 HTTP/2 中多个消息交织在了一起，这无疑提高了“通信”的效率。这就是多路复用：<strong>在一个 HTTP 的连接上，多路“HTTP 消息”同时工作</strong>。(具体见下图)<br><img src="https://cdn.jsdelivr.net/gh/alileew/alileew_images/img/202208152104655.png"></p><figcaption>多路复用-202208152104655.png</figcaption><p>为什么 http1.1 不能使用【多路复用】呢？因为 <strong>HTTP/2 是基于二进制“帧”的协议，HTTP/1.1 是基于“文本分割”解析的协议。</strong></p></li></ul></li><li><p>头部压缩</p><ul><li><p>减少头部需要传输的信息量，每次请求都会重复的发送对用的 request header（几 k-几百 k）会消耗更多的资源。所以 H2.0 采用了<code>hpack</code>算法(<strong>原理：用 header 字段表里的索引代替实际的 header</strong>)进行头部压缩，具体做法就是：通讯双方持有一份字典（静态(content-type method ⇒ 直接发索引)表/动态表），对于表内的字段（值），直接发放索引。<br><img src="https://cdn.jsdelivr.net/gh/alileew/alileew_images/img/202208152106677.png"></p><figcaption>header字段表-202208152106677.png</figcaption><p><img src="https://cdn.jsdelivr.net/gh/alileew/alileew_images/img/202208152106383.png"></p><figcaption>hpack-header-compression-202208152106383.png</figcaption></li></ul></li><li><p>服务端推送</p><ul><li>主动下发关键资源</li></ul></li></ul><h2 id="HTTP2-带来的变化"><a href="#HTTP2-带来的变化" class="headerlink" title="HTTP2 带来的变化"></a>HTTP2 带来的变化</h2><ul><li><p>原本依赖多个 tcp 连接，现在都集中在同一个连接上(多个请求可以共有一个 TCP 连接)，网络效率高了很多，但可能会造成性能瓶颈</p></li><li><p>一些性能优化手段已经失效了，例如：</p><ul><li>雪碧图之类的资源合并 - 发起请求成本降低</li><li>资源内嵌 - 通过 <code>server push</code> 主动下发</li></ul></li><li><p>但有一些依然有效</p><ul><li>压缩（Nginx 开启 gzip 压缩）</li></ul><pre><code class="jsx"># 开启gzip 压缩gzip on;# 设置gzip所需的http协议最低版本 （HTTP/1.1, HTTP/1.0）gzip_http_version 1.1;# 设置压缩级别，压缩级别越高压缩时间越长  （1-9）gzip_comp_level 4;# 设置压缩的最小字节数， 页面Content-Length获取gzip_min_length 1000;# 设置压缩文件的类型  （text/html)gzip_types text/plain application/javascript text/css;</code></pre><ul><li>CDN（内容分发网络）<br>CDN 服务提供商将源站的资源缓存到全国各地的高性能加速节点。当用户访问相应的服务资源时，会将用户调度到最近的节点，并将最近的节点 IP 返回给用户，使用户就近获取所需内容，从而可以更快、更稳定地传输内容。CDN 的核心点有两个，一个是缓存，一个是回源：<ol><li>缓存： 将源服务器请求来的资源按要求缓存。</li><li>回源：CDN 节点没有响应到应该缓存的资源（没有缓存过或者是缓存已经到期），就会回源站去获取</li></ol></li><li>缓存 等等</li></ul></li></ul><h2 id="HTTP2-存在的问题"><a href="#HTTP2-存在的问题" class="headerlink" title="HTTP2 存在的问题"></a>HTTP2 存在的问题</h2><ol><li>HTTP2 虽然在请求的通信上带来了很大的性能提升，但所有的请求都是基于一个 TCP 之上的，一旦请求的数量过多，就会带来一定的性能瓶颈。</li><li>TCP 层面的<code>队首阻塞</code> (abcd ⇒ b 出错了 ⇒ cd 也会被阻塞) 但在HTTP/2 中一个域名又只使用一个 TCP 连接，一个一个请求是跑在一个 TCP 长连接中的，如果其中一个数据流出现了丢包的情况，那么就会阻塞该 TCP 连接中的所有请求，进而影响了HTTP/2 的传输效率。</li><li>所以再此基础之上有了 HTTP3.0 的提议。</li></ol><hr><h2 id="HTTP3-0-展望"><a href="#HTTP3-0-展望" class="headerlink" title="HTTP3.0 展望"></a>HTTP3.0 展望</h2><p>HTTP/3和HTTP/2主要区别在于 HTTP/3 基于 QUIC 作为传输层来处理流，而 HTTP/2 使用 TCP 来处理 HTTP 层中的流。<br>可以把 QUIC 看成是集成了“TCP+HTTP/2 的多路复用 +TLS ”的一套协议。其中的快速握手功能（基于UDP）实现了使用 0-RTT 或者 1-RTT 来建立连接，可以大大提升首次打开页面的速度。</p><ul><li>H3 解决方法 ⇒ TCP ⇒ UDP<br><img src="https://cdn.jsdelivr.net/gh/alileew/alileew_images/img/202208152123136.png"><ul><li>H2 基于 TCP，HTTP3 直接基于 UDP ⇒ QUIC（quick udp internet connection）</li><li>QUIC 是基于 UDP 实现的；丢包回复、拥塞控制、加解密（TLS1.3）、多路复用逻辑<ul><li>优势<ul><li>启动性能：无需 TCP 三次握手；</li><li>TLS 建联之前发送请求 ⇒ 3RTT(<code>Round-Trip-Time 往返时间</code>) ⇒ 0/1 RTT<br><img src="https://s1.51cto.com/oss/202009/12/d4d682c990da3034971f4e95450bdf4b.gif"></li><li>解决 TCP 队首阻塞</li></ul></li><li>缺点<ul><li>兼容性差</li><li>用户态 ⇒ 性能问题</li></ul></li></ul></li></ul></li></ul><hr><p>参考：</p><ol><li><a href="https://halfrost.com/http2-header-compression/#toc-5">详解 HTTP/2 头压缩算法 —— HPACK</a></li><li><a href="https://zhuanlan.zhihu.com/p/405387352">QUIC协议详解</a></li><li><a href="https://jelly.jd.com/article/6006b1035b6c6a01506c879b">前端开发与 HTTP/2 的羁绊</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;HTTP(Hyper Text Transfer Protocol-超文本传输协议)是一个简单的请求-响应协议，它通常运行在&lt;a href=&quot;https://baike.baidu.com/item/TCP/33012&quot;&gt;TCP&lt;/a&gt;之上。它指定了客户端可能发送给服务器什</summary>
      
    
    
    
    
    <category term="HTTP" scheme="http://example.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>聊聊浏览器的缓存策略</title>
    <link href="http://example.com/archives/60150/"/>
    <id>http://example.com/archives/60150/</id>
    <published>2022-03-27T03:08:31.000Z</published>
    <updated>2024-10-12T02:10:53.545Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么会有浏览器缓存策略"><a href="#为什么会有浏览器缓存策略" class="headerlink" title="为什么会有浏览器缓存策略"></a>为什么会有浏览器缓存策略</h2><ol><li>减少重复数据请求，避免通过网络再次加载资源，节省流量。</li><li>降低服务器的压力，提升网站性能。</li><li>加快客户端加载网页的速度， 提升用户体验。</li></ol><h2 id="何谓-【强缓存-vs-协商缓存】"><a href="#何谓-【强缓存-vs-协商缓存】" class="headerlink" title="何谓 【强缓存 vs 协商缓存】"></a>何谓 【强缓存 vs 协商缓存】</h2><p>强缓存:<br>若浏览器有缓存副本且未过期，则直接使用强缓存版本 <code>cache-control: max-age</code></p><p>协商缓存:<br>即使本地有副本，也会携带缓存标识 <code>If-modified-since/If-none-match</code>到服务器验证副本有效性,<br>如果生效返回<code>304</code>，负责直接返回<code>200</code></p><h2 id="页面如何命中-强缓存和协商缓存？"><a href="#页面如何命中-强缓存和协商缓存？" class="headerlink" title="页面如何命中 强缓存和协商缓存？"></a>页面如何命中 强缓存和协商缓存？</h2><p><img src="https://cdn.jsdelivr.net/gh/alileew/alileew_images/img/202204051756683.png"></p><figcaption>浏览器缓存经典流程图-202204051756683.png</figcaption><p>首先我们引用上面这幅经典的流程图进行说明：</p><ol><li>浏览器在访问页面的时候，判断页面是否有被缓存过，如果有缓存，直接从缓存中读取数据进行访问即可。</li><li>如果没有缓存或缓存已过期，访问页面后，服务器会在<code>Response Headers</code>（在 Header 内的字段用于控制缓存机制）中返回一个<code>Etag</code>的标识符，第二次访问此页面时，会在<code>Request Headers</code>（在 Header 内的字段用于控制缓存机制）中携带对应的<code>If-none-match</code>，这个<code>If-none-match</code>和上面后端返回的<code>Etag</code>是一致的，因为值是<code>Etag</code>的值,这时候服务器会进行决策，如果返回<code>200</code>则请求响应，进行缓存协商。如果返回<code>304</code>，则从缓存读取。</li><li>步骤同2，如果<code>Etag</code>没有，则对应的查看是否有<code>last-modified</code>…..</li><li>如果<code>Etag</code>和<code>last-modified</code>都不存在，此时就只能服务器请求新的资源了…</li></ol><h2 id="网址链接实例讲解"><a href="#网址链接实例讲解" class="headerlink" title="网址链接实例讲解"></a>网址链接实例讲解</h2><p>我们以 juejin.cn 为例进行讲解</p><p>首次访问新链接后，页面会走协商缓存，服务端会在<code>Response Headers</code>中返回一个<code>Etag</code>的标识符。<br><img src="https://cdn.jsdelivr.net/gh/alileew/alileew_images/img/202204051946208.png"></p><figcaption>首次输入juejin.cn链接后...202204051946208.png</figcaption><hr><p>再次（第二次）访问此链接后，<code>Request Headers</code>中携带对应的<code>If-none-match</code>，这个<code>If-none-match</code>和上面后端返回的<code>Etag</code>是一致的。此时携带此标识（If-none-match）到服务器端验证副本有效性，如果生效返回<code>304</code>，否则直接返回结果<code>200</code><br><img src="https://cdn.jsdelivr.net/gh/alileew/alileew_images/img/202204051953938.png"></p><figcaption>再次访问juejin.cn链接后,标识符匹配后...202204051953938.png</figcaption><hr><p>间隔一段时间后，缓存失效后，再次访问juejin.cn链接后, <code>If-none-match和Etag不一致</code>，此时缓存时效，此时会重新请求服务器获取新的资源<br><img src="https://cdn.jsdelivr.net/gh/alileew/alileew_images/img/202204052008883.png"></p><figcaption>缓存失效后，再次访问juejin.cn链接后,标识符不一致时...202204052008883.png</figcaption><hr><p><b>画个图 总结一下</b>（这里以Etag和If-none-match为例）:<br>Last-Modified和If-modified-since流程同Etag和If-none-match一致</p><p><img src="https://cdn.jsdelivr.net/gh/alileew/alileew_images/img/202204052020316.png"></p><figcaption>强缓存/协商缓存小结图-202204052020316.png</figcaption><p>Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，If-none-match是客户端再次发起该请求时，携带上次请求返回的唯一标识Etag值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有If-none-match，则会根据If-none-match的字段值与该资源在服务器的Etag值做对比，一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为200。</p><p>If-modified-since则是客户端再次发起该请求时，携带上次请求返回的Last-Modified值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有If-modified-since字段，则会根据If-modified-since的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于If-modified-since的字段值，则重新返回资源，状态码为200；否则则返回304，代表资源无更新，可继续使用缓存文件</p><hr><p><code>Etag/If-none-match</code> 优先级高于 <code>Last-Modified/If-modified-since</code></p><h2 id="Last-Modified-Etag区别"><a href="#Last-Modified-Etag区别" class="headerlink" title="Last-Modified/Etag区别"></a><code>Last-Modified/Etag</code>区别</h2><p>相同点：</p><ul><li>两者都是用来处理协商缓存的</li></ul><p>不同点：</p><ul><li>last-modified 是根据文件修改时间，它的优点是计算量会更小，它就是根据文件的存储时间判断；但缺点就是非内容块改变（比如：只是meta标签发生了变化，但文件内容没有变化的情况下）系统也会判断这是一个新修改过的文件，这个时候就可能会造成缓存失效，还有就是last-modified单位是秒，如果一秒内修改了文件，last-modified是检测不到的。基于上面几种情况，所以选用了 Etag</li><li>Etag 是根据文件内容算出摘要，只有内容变化，Etag才会发生变化，那这样就可以保证，一定是文件内容发生了变化，缓存才会失效。缺点就是有一个摘要的计算（现在是依托在服务器的<code>nginx</code>中做摘要计算），可能会比较耗时</li></ul><hr><p><b>所以现在我们常用的比较好的缓存实践就是：</b></p><ul><li>文件名使用<code>hash</code>做路径标识 + 配合强缓存</li><li>应用缓存 — <code>App Cache and Manifest</code>文件</li><li>用<code>localstorage</code> — 做缓存</li><li><code>Service Worker</code> — 实现自定义的网络请求逻辑</li></ul><hr><blockquote><p>在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存</p></blockquote><p>Cache-Control: </p><ol><li>public：所有内容都将被缓存（客户端和代理服务器都可缓存）</li><li>private：所有内容只有客户端可以缓存，Cache-Control的默认取值</li><li>no-cache【<code>重点</code>】：告诉浏览器、缓存服务器，不管本地副本是否过期(last-modified)适应资源副本前一定要到原服务器进行副本有效性校验. 简单理解就是：<code>指示浏览器每次使用url的缓存版本之前都必须与服务器重新验证</code></li><li>no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存</li><li>max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效</li><li>must-revalidate：告诉浏览器、缓存服务器，本地副本过期前，可以使用本地副本；本地副本一旦过期，必须去源服务器进行有效性校验</li></ol><p>注意：<code>cache-control: max-age=0</code> 暗示内容立即被认为是陈旧的（并且必须重新获取），这实际上与<code>cache-control: no-cache</code> 相同</p><hr><p>注意点：</p><ol><li>获取缓存检测缓存是否过期，如果没过期取缓存</li><li>优先从内存，其次硬盘，如果过期，则与服务器协商缓存是否仍然可用，如果不可用则获取，可用取缓存</li><li>cache会在页面关闭时写入磁盘，下次打开同一站点时检测到未过期则会使用disk</li></ol><hr><p>如果文章有错误或者不严谨的地方，请务必给予指正，十分感谢 ~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;为什么会有浏览器缓存策略&quot;&gt;&lt;a href=&quot;#为什么会有浏览器缓存策略&quot; class=&quot;headerlink&quot; title=&quot;为什么会有浏览器缓存策略&quot;&gt;&lt;/a&gt;为什么会有浏览器缓存策略&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;减少重复数据请求，避免通过网络再次加载资源，节省</summary>
      
    
    
    
    
    <category term="浏览器缓存" scheme="http://example.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>如何封装通用型Table分页组件并自定义相关Hook</title>
    <link href="http://example.com/archives/60809/"/>
    <id>http://example.com/archives/60809/</id>
    <published>2022-03-19T07:38:27.000Z</published>
    <updated>2024-10-12T02:10:53.545Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>日常开发中，我们再对一个 Table 进行分页处理的过程时，虽然 AntD Table 已经为我们做了很多的处理。 <a href="https://ant.design/components/table-cn/#header">AntD Table</a> 但是各种 onChange 事件到处都是，导致每个页面有这种Table分页功能的话，每次都要重复写好多。</p><p><img src="https://cdn.jsdelivr.net/gh/alileew/alileew_images/img/202203191540273.png"></p><figcaption>hooks-202203191540273.png</figcaption><p>获取<code>pageSize/currentPage/total/...</code>每次都要定义一遍来获取对应的值，这样无疑要维护很多的 <code>useState</code> </p><pre><code class="javascript">const [pageSize, setPageSize] = useState(10);const [currentPage, setCurrentPage] = useState(1);const [total, setTotal] = useState(10);...</code></pre><p>其实完全可以封装一个专门处理page分页的 <code>hooks</code> 封装前，我们先要知道我们需要处理哪些数据？</p><blockquote><p>如下这些是 Table 必须的值：<br>  currentPage、setCurrentPage、pageSize、setPageSize、total、setTotal<br>  onChange、onShowSizeChange、resetPage</p></blockquote><hr><h2 id="如何封装"><a href="#如何封装" class="headerlink" title="如何封装"></a>如何封装</h2><pre><code class="javascript">import &#123; useState &#125; from &#39;react&#39;;const DEFAULT_CURRENT_PAGE = 1;const DEFAULT_PAGE_SIZE = 10;const DEFAULT_TOTAL = 10;export default function (): &#123;  currentPage: number;  pageSize: number;  total?: number;  setPageSize(pageSize: number): void;  setCurrentPage(currentPage: number): void;  onChange(currentPage: number, pageSize?: number | undefined): void;  onShowSizeChange(currentPage: number, pageSize: number): void;  resetPage(): void;  setTotal(total: number): void;&#125; &#123;  const [pageSize, setPageSize] = useState&lt;number&gt;(DEFAULT_PAGE_SIZE);  const [currentPage, setCurrentPage] = useState&lt;number&gt;(DEFAULT_CURRENT_PAGE);  const [total, setTotal] = useState&lt;number&gt;(DEFAULT_TOTAL);  // 获取对应的分页及每页数据  const onChange = (currentPage: number, pageSize: number) =&gt; &#123;    setPageSize(pageSize);    setCurrentPage(currentPage);  &#125;;  const onShowSizeChange = (currentPage: number, pageSize: number) =&gt; &#123;    setPageSize(pageSize);    setCurrentPage(DEFAULT_CURRENT_PAGE);  &#125;;  // 重置分页数据  const resetPage = () =&gt; &#123;    setPageSize(DEFAULT_PAGE_SIZE);    setCurrentPage(DEFAULT_CURRENT_PAGE);  &#125;;  return &#123;    pageSize,    currentPage,    setPageSize,    setCurrentPage,    onChange,    onShowSizeChange,    resetPage,    total,    setTotal,  &#125;;&#125;</code></pre><hr><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><pre><code class="javascript">import &#123; useEffect &#125; from &#39;react&#39;;import usePageHooks from &#39;../pageHooks&#39;; // 从对应文件引入pageHooks组件const &#123;  pageSize,  currentPage,  onChange,  onShowSizeChange,  total,  setTotal&#125; = usePageHooks();// 页面初始化，默认拿到table有多少条数据useEffect(() =&gt; &#123;  setTotal(data.length); &#125;,[]);&lt;Table  columns=&#123;columns&#125;  dataSource=&#123;data&#125;  pagination=&#123;&#123;    pageSize,    current: currentPage,    showQuickJumper: true,    showSizeChanger: true,    onChange,    onShowSizeChange,    total,    showTotal: (total: number, range: number[]) =>       `第 $&#123;range[0]&#125;-$&#123;range[1]&#125; 条 / 共 $&#123;total&#125; 条`,  &#125;&#125;/&gt;</code></pre><hr><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过 <code>pageHooks</code> 组件，我们就完成了一个通用 table 分页功能.<br>这样每个页面就不需要再单独维护 <code>pageSize, currentPage, ...</code> 这些 useState.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;日常开发中，我们再对一个 Table 进行分页处理的过程时，虽然 AntD Table 已经为我们做了很多的处理。 &lt;a href=&quot;htt</summary>
      
    
    
    
    
    <category term="React Hooks" scheme="http://example.com/tags/React-Hooks/"/>
    
    <category term="Ant Design" scheme="http://example.com/tags/Ant-Design/"/>
    
  </entry>
  
  <entry>
    <title>前端经典面试之闭包</title>
    <link href="http://example.com/archives/46656/"/>
    <id>http://example.com/archives/46656/</id>
    <published>2022-03-13T01:39:55.000Z</published>
    <updated>2024-10-12T02:10:53.544Z</updated>
    
    <content type="html"><![CDATA[<p>在面试时，我常问候选人老生常谈的一个问题便是「聊聊你对闭包的理解，闭包是如何存储变量的？又是如何回收的？」</p><p>百分之90的候选人，都是回答：”函数内部可以访问外部的变量，就形成了闭包”，当然我不能说候选人这种说法一定是错的，只是太字面了。于是，我继续追问，可以再具体一点吗？为什么内部可以访问外部的变量就形成了闭包，它是怎么存储并回收的呢？这时候，候选人就回答不上来了。</p><p><b>如果对闭包理解深一点的同学可能会这么回答：</b><br>「在 JavaScript中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包」这个回答还算标准一些，至少他了解闭包中的函数什么时候会执行结束，知道变量会被存在内存中。</p><p>其实，想要回答好闭包这个问题。那么理解作用域链是理解闭包的基础，但理解作用域链又需要了解 <code>调用栈、执行上下文、词法环境、变量环境。</code></p><p>变量是通过作用域链来查找的，变量的作用域是由词法决定的，也就是说作用域是在你写代码的时候就已经决定了的(取决于代码的位置)。那么什么是词法作用域呢？</p><p>💡 词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。</p><p>💡 <code>词法作用域是代码编译阶段就决定好的</code> 和函数是怎么调用的没有关系。JavaScript 语言的作用域链是由词法作用域决定的，而词法作用域是由代码结构来确定的。</p><blockquote><p>引用《你不知道的js》中的定义：<br>  闭包是基于词法作用域书写代码时所产生的自然结果。当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。</p></blockquote><p><b>那么 闭包是如何回收的：</b><br>通常，如果引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭；但如果这个闭包以后不再使用的话，就会造成内存泄漏。如果引用闭包的函数是个局部变量，等函数销毁后，在下次 JavaScript 引擎执行垃圾回收时，判断闭包这块内容如果已经不再被使用了，那么 JavaScript 引擎的垃圾回收器就会回收这块内存。</p><p><b>使用必要需要注意的原则：</b><br>💡 如果该闭包会一直使用，那么他可以作为全局变量而存在；但如果使用率不高，而且占用内存又比较大的话，那就让他成为一个局部变量</p><p>上面我们简单总结了闭包的大概流程，下面就从堆栈空间的角度在深入分析闭包的形成及调用过程.<br>在理解这个概念之前，首先我们要知道 “内存空间”，JS的内存模型包含三种类型的内存空间，分别是：</p><ul><li>代码空间（主要用来存储可执行代码的）</li><li>堆空间（主要用来存储对象类型）<ul><li>缺点：分配内存和回收内存会占用一定的时间</li></ul></li><li>栈空间（其实就是调用栈，用来存储执行上下文的，主要存放一些原始类型的小数据）</li></ul><p>对象类型是存放在堆空间的，在栈空间只是保留了对象的引用地址，当JS需要访问数据的时候，是通过栈中的引用地址来访问的（这块是不是想起了基本类型和引用类型的区别）</p><p>所以，你可以理解成，<code>原始类型的数据值都是用来直接保存&quot;栈&quot;中的, 引用类型的值是存放在&quot;堆&quot;中的</code></p><p>说了这么多很干的概念，为了带你回顾上面的概念，不只是停留在闭包概念的理解，这里引入代码进行解读：</p><pre><code class="javascript">function foo() &#123;  var myName = &quot;李小宝&quot;  let test1 = 1  const test2 = 2  var innerBar = &#123;     setName:function(newName)&#123;      myName = newName    &#125;,    getName:function()&#123;      console.log(test1)        return myName      &#125;    &#125;  return innerBar&#125;var bar = foo()bar.setName(&quot;李大宝&quot;)bar.getName()console.log(bar.getName())</code></pre><p><b>分析阶段：</b><br>由于变量 myName、test1、test2 都是原始类型数据，所以在执行foo函数的时候，它们会被压入到调用栈中；当foo函数执行结束之后，调用栈中foo函数的执行上下文会被销毁，但是因为foo函数产生了闭包，所以变量myName和test1并没有被销毁，而是保存在内存中。</p><p>为什么会保存在内存中？「首先要站在内存模型的角度分析代码的执行流程」</p><ol><li>当 JavaScript 引擎执行到 foo 函数时，首先会编译，并创建一个空执行上下文。</li><li>在编译过程中，遇到内部函数 setName，JavaScript 引擎还要对内部函数做一次快速的词法扫描，发现该内部函数引用了 foo 函数中的 myName 变量，由于是内部函数引用了外部函数的变量，所以 JavaScript 引擎判断这是一个闭包，于是在堆空间创建了一个“closure(foo)”的对象（这是一个内部对象，JavaScript 是无法访问的），用来保存 myName 变量。</li><li>接着继续扫描到 getName 方法时，发现该函数内部还引用变量 test1，于是 JavaScript 引擎又将 test1 添加到“closure(foo)”对象中。这时候堆中的“closure(foo)”对象中就包含了 myName 和 test1 两个变量了。</li><li>由于 test2 并没有被内部函数引用，所以 test2 依然保存在调用栈中。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/alileew/alileew_images/img/202203131043147.png"></p><figcaption>js-202203131043147.png</figcaption><p>从上图你可以清晰地看出，当执行到 foo 函数时，闭包就产生了；当 foo 函数执行结束之后，返回的 getName 和 setName 方法都引用“clourse(foo)”对象，所以即使 foo 函数退出了，“clourse(foo)”依然被其内部的 getName 和 setName 方法引用。所以在下次调用bar.setName或者bar.getName时，创建的执行上下文中就包含了“clourse(foo)”</p><p><strong><code>结论：产生闭包的核心有两步：</code></strong></p><ul><li><strong><code>第一步是需要预扫描内部函数；</code></strong></li><li><strong><code>第二步是把内部函数引用的外部变量保存到堆中。</code></strong></li></ul><hr><p>现在我们通过上面的例子，已经了解了闭包的产生及存储过程。下面，我为你准备了一个更简单的例子，直接对着这个来回答闭包的问题，话不多说，上代码：</p><pre><code class="javascript">// 举一个简单的例子进行说明:function A() &#123;  var a = &#39;我是小a&#39;;  let b = &quot;我是小b&quot;  var B = function() &#123;    console.log(a)  &#125;  return B()&#125;A()</code></pre><p><b>引用上面的概念：</b><br>在JavaScript中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。</p><p><b>简单理解就是：</b><br>A函数中有个B函数，B函数可以访问A函数中的变量，此时就把A函数中的变量的集合称为闭包。由于A函数中的变量a是原始类型数据，所以在执行A函数的时候，它会被压入到调用栈中；当A函数执行结束之后，调用栈中A函数的执行上下文会被销毁，但是因为A函数产生了闭包，所以变量a并没有被销毁，而是保存在内存中。</p><p><b>变量a之所以会被保存在内存中:</b><br>主要是因为在编译代码的过程中，遇到内部函数B的时候，<code>JS引擎对内部函数要做一次快速的词法扫描</code> ，如果发现该内部函数引用了A函数中的a变量，JS引擎判断出这个一个闭包，就在堆空间创建了一个<code>&quot;closure(A)&quot;</code> 的对象（这是一个内部对象，JS是无法访问的），这个对象用来保存a变量。如果还有其它的变量，也依次将其添加到这个<code>&quot;closure(A)&quot;</code> 对象中。<code>由于变量b并没有被内部函数引用，所以b依然保存在调用栈中。</code></p><p><b>为什么函数B函数执行退出后，为什么A函数中的a还被引用？</b><br>这是因为B函数退出后，”closure(A)”依然被其内部的B函数引用。所以在下次调用A函数的时候，创建的执行上下文中就包含了”closure(A)”</p><p><b>内存是如何泄漏的？如何避免写代码的时候产生内存泄漏?</b><br>1.函数A声明的变量a在函数B被执行成功退出之后，依然保留对a的引用，没有及时卸载掉，内存依然还在，就产生了内存泄漏。<br>2.及时清除未使用过的变量 如：a = null; 或者尽量避免在内部作用域内声明函数对外部的引用。</p><p>以上就是对闭包原理的解读以及如何更好的回答面试官 关于闭包的这个问题的阐述，相信你下一次再被面试官问到这个问题的时候，能从上面的角度去回答，那会给面试官一个很大的惊喜。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在面试时，我常问候选人老生常谈的一个问题便是「聊聊你对闭包的理解，闭包是如何存储变量的？又是如何回收的？」&lt;/p&gt;
&lt;p&gt;百分之90的候选人，都是回答：”函数内部可以访问外部的变量，就形成了闭包”，当然我不能说候选人这种说法一定是错的，只是太字面了。于是，我继续追问，可以再</summary>
      
    
    
    
    
    <category term="JS" scheme="http://example.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>浅谈对 Vue、React 数据更新的理解</title>
    <link href="http://example.com/archives/3006/"/>
    <id>http://example.com/archives/3006/</id>
    <published>2022-01-08T01:41:06.000Z</published>
    <updated>2024-10-12T02:10:53.545Z</updated>
    
    <content type="html"><![CDATA[<p>说两者之前要先简单讲一下前端的 “刀耕火种” 的年代，从后端渲染模板 → jQuery 直接操作 DOM → mvvm 的虚拟 DOM → 工程化。</p><p>Vue1.0 的解决方案，采用的是响应式，初始化的时候，Watcher 监听了数据的每个属性，这样数据发生变化的时候，我们就能精确地知道数据的哪个 key 变了，然后再去针对性修改对应的 DOM 即可，这个 DOM 是真实的 DOM，而非虚拟 DOM。好处就是，响应式的数据监听，不需要人为的去操纵数据。但坏处就是，Vue 中每个真实的元素都要绑定一个 Watcher，元素一旦过多，Watcher 的数量就比较大，致使数据在更新、渲染 DOM 的时候，时间更多，对性能产生影响。</p><p>所以 Vue2.0 借鉴了 React 虚拟 DOM 思想，在 Vue2.0 中引入了虚拟 DOM 的概念，那么何为虚拟 DOM 呢，其实就是一个对象，这个对象完整的描述了对象的树形结构，这样数据有变化的时候，就会生成一份新的虚拟 DOM 数据，然后再对之前的虚拟 DOM 进行计算，算出需要修改的 DOM，再去页面进行操作，这就是 「数据驱动页面」的方式，这样规避了 jQuery 和 Vue1.0 那种直接操作 DOM 对性能的影响。浏览器操作 DOM 一直都是性能杀手，而虚拟 DOM 的 Diff 的逻辑，又能够确保尽可能少的操作 DOM，这也是虚拟 DOM 驱动的框架性能一直比较优秀的原因之一。</p><pre><code class="javascript">// 虚拟 DOM，其实就是一个对象，也就是React中通过createElement创建的.// ReactElement通过createElement创建，调用该方法需要传入三个参数：type、config、children&#123;  &quot;tag&quot;: &quot;div&quot;,  &quot;attrs&quot;: &#123;    &quot;id&quot;: &quot;app&quot;  &#125;,  &quot;children&quot;: [    &#123;      &quot;tag&quot;: &quot;p&quot;,      &quot;attrs&quot;: &#123;        &quot;className&quot;: &quot;item&quot;      &#125;,      &quot;children&quot;: [&quot;Item1&quot;]    &#125;,    &#123;      &quot;tag&quot;: &quot;div&quot;,      &quot;attrs&quot;: &#123;        &quot;className&quot;: &quot;item&quot;      &#125;,      &quot;children&quot;: [&quot;Item2&quot;]    &#125;  ]&#125;</code></pre><p>Vue 和 React 对数据改变后通知页面进行更新，采用的是两种不同的机制。</p><p class="article-highlight">Vue框架下，如果数据发生了改变，框架会主动告诉你修改了哪些数据「响应式/双向绑定模式」；React的数据发生变化后，只能通过新老数据的计算Diff来得知数据的改变；</p>这两个方案都解决了数据变化后，如何通知页面更新的问题，但是都有对应的弊端。<p>上面开始的时候，有提到过，对于 Vue 来说，它的核心就是 “响应式” 也就是数据变化后，会主动通知我们，响应式数据新建 Watcher 监听，本身就比较耗费性能，项目大了之后每个数据都有一个 Watcher，会更影响性能。</p><p>对于 React 的虚拟 DOM 的 Diff 比对逻辑来说，如果虚拟 DOM 数过于庞大，使得计算时间大于 16.6ms<span class="article-highlight">「1s 渲染 60 次，1 帧 ⇒ 1s/60fps = 16.6ms」</span>在这 16.6ms 里，浏览器自己的渲染更新任务执行后，会有一部分的空闲时间，这段时间就是用来计算 Diff 的，所以，一旦时间超过 16.6ms，就可能会造成性能的卡顿，为了解决这个卡顿，之后 React 做了新的架构 Fiber，这个后面会提到。</p><p>为了解决性能瓶颈，Vue 和 React 走了不同的道路：<br>在 React 中 由于递归执行，所以更新一旦开始，中途就无法中断。当层级很深时，递归更新时间超过了 16ms，用户交互就会卡顿。</p><p>React 为了突破性能瓶颈，借鉴了操作系统时间分片的概念，引入了新的 Fiber 架构，将其虚拟 DOM <code>从树形 → 链表</code>，利用浏览器的空闲时间计算，进行 相应的 Diff 操作，就是一旦浏览器有任务，我们就先把没计算完的任务放在一边，把主进程控制权交还给浏览器，等待浏览器空闲了，再把新的任务交给浏览器进行计算，使得任务可中断、可暂停、可分片….巧妙的利用了浏览器的空闲时间，解决了卡顿的问题。</p><p>那么链表具体是如何对数据进行比对的呢，其实是遍历通过 child → sibling → parent 元素的逻辑，随时可以中断和恢复 Diff 的计算过程。</p><p>Vue1.0 的问题在于响应式的数据过多，会带来内存占用过多的问题，所以 Vue2.0 引入了虚拟 DOM 来解决响应式数据过多的问题。</p><p class="article-highlight">响应式数据是主动推送变化，虚拟 DOM 是被动计算数据的Diff，所以Vue2.0 采用了组件级别的划分，就是每个组件都被独立的Watcher监听。</p>那么问题来了，Vue为什么不需要React的Fiber呢？<p>答：是因为Vue将虚拟 DOM 控制在组件级, 每次变化影响的只是一颗子树, 相对范围小</p><ol><li>Vue3 把虚拟 Dom 控制在组件级别，组件之间使用响应式，这就让 Vue3 的虚拟 Dom 不会过于庞大</li><li>Vue3 虚拟 Dom 的静态标记和自动缓存功能，让静态的节点和属性可以直接绕过 Diff 逻辑，也大大减少了虚拟 Dom 的 Diff 事件</li><li>时间切片也会带来额外的系统复杂性</li></ol><p>这就是为什么 Vue 没有采用 Fiber 的原因，本质还是数据更新通知机制不一样，Vue 是主动推送，而且 Watcher 对应的是组件级。这跟 React Diff 算法是不一样的，React Diff 是被动计算数据的 Diff。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;说两者之前要先简单讲一下前端的 “刀耕火种” 的年代，从后端渲染模板 → jQuery 直接操作 DOM → mvvm 的虚拟 DOM → 工程化。&lt;/p&gt;
&lt;p&gt;Vue1.0 的解决方案，采用的是响应式，初始化的时候，Watcher 监听了数据的每个属性，这样数据发生变化</summary>
      
    
    
    
    
    <category term="React" scheme="http://example.com/tags/React/"/>
    
    <category term="Vue" scheme="http://example.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>2021 年终总结</title>
    <link href="http://example.com/archives/15600/"/>
    <id>http://example.com/archives/15600/</id>
    <published>2021-12-31T13:46:11.000Z</published>
    <updated>2024-10-12T02:10:53.543Z</updated>
    
    <content type="html"><![CDATA[<p>许久没在网络上写自己的年终总结了，上次在掘金写 “年度征文” 还是好几年前的事情。自从 2020 年将知识和笔记重点 转向了 Notion，慢慢养成了一些写作的习惯，每年的年终总结都放在了 Notion。</p><p>2021 下半年搭建了<a href="https://www.vonmo.cn/">个人博客</a>，还是想着应该把年终总结放到博客上，这样可以给自己一个正向反馈，也分享给那些你可以影响的人，也给自己过去一年做了记录，那就谈谈这一年来的得（收获）与失（教训）吧。</p><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>2020 年 12 月份入职新公司，首次接触了中台，参与开发并重构了好几个比较重要的项目，给团队分享了很多比较有干货、有质量的文章，在团队中给组员做了高质量的 git 布道（入职之前，他们都是用 sourceTree 做一些简单的拉取及提交代码的事情）让团队对 git 的认识又上升了一个维度，规范了 git 提交流程。推进了 TypeScript 在团队项目中的落地。React 全家桶 + TypeScript 在日常开发中，大大的提升并改善了代码的整体质量。</p><p>这一来年参与的项目开发，共提交了<code>7万多行</code>代码，使用最多的语言是<code>JavaScript、TypeScript</code>这一年在团队中分享了<code>20篇左右</code>的技术文章，涉及到的有 git/js/react/redux/route/markdown/linux/clean-code/… 以及各种能提升开发效率的工具。</p><p><img src="https://cdn.jsdelivr.net/gh/alileew/alileew_images/img/20211231215319.png"></p><figcaption>代码提交记录图「code-20211231215319.png」</figcaption><p><img src="https://cdn.jsdelivr.net/gh/alileew/alileew_images/img/20211231215425.png"></p><figcaption>开发语言提交折线图「code-20211231215425.png」</figcaption><p><img src="https://cdn.jsdelivr.net/gh/alileew/alileew_images/img/20211231215511.png"></p><figcaption>开发语言饼状图「code-20211231215511.png」</figcaption><p>年底被提名，答辩晋升通过，算是对这一年来自己工作成果的认可。</p><p>这一年，承担了公司及团队内的面试官一职，参与面试了 <code>100份左右简历</code> 在面试中也感受到了形形色色的人，了解了他们对技术的不同看法，让我在学习的时候，也有了更多的思考。这一年中，断断续续的在团队带过两个新人，从他们身上，看到了自己当年刚毕业工作时候的样子，给他们传授了一些学习方法，他们日常遇到的问题，我更倾向于给他们提供解决的思路，引导他们思考，让他们开发思维可以有一些转变，这也是一件让我感到很开心的事。</p><h2 id="健身"><a href="#健身" class="headerlink" title="健身"></a>健身</h2><p>新公司有健身房，算是薅了个福利，基本上每天早上都是早早的到办公室了，锻炼一个小时左右，洗漱完，回工位开始一整天的开发。身体素质这块，还算维持的还行，时刻提醒自己，不让自己成为油腻大叔，去年的年终总结是希望今年（2021）年体重降到 70KG，看来是要失败了，现在「175CM/75KG」只能将目标延至到下一年了。</p><h2 id="效率软件"><a href="#效率软件" class="headerlink" title="效率软件"></a>效率软件</h2><p>这一年，发现了一些可以提高效率的网站/APP, 这里推荐两个提高日常效率的软件：</p><ol><li><a href="https://cubox.pro/">cubox</a><br>因为我上下班地铁通勤时间比较长，所以地铁上会零散的看一些文章，但经常看完就丢了，下次再想看就找不到了，就很麻烦。无意中发现了 cubox 这个应用，它可以给每一个书签加上标签，日后我可以通过 tag 的组合找到忘掉的东西。</li></ol><ul><li>我现在看到无法短时间消化的文章，都可以收藏到 Read it later 的文件夹里，定期统一处理</li><li>在移动端用 share sheet 也可以很方便把移动端上看到的页面收藏到 Cubox</li></ul><ol start="2"><li><a href="https://dida365.com/">滴答清单</a><br>以前每次写代办事项，都是先在 Notion 中去罗列这一天/周/月来要做的事情，但是一旦白天忙起来，事情就容易忘记，有了滴答清单，它可以帮你高效完成任务和规划时间，你可以直接在应用中输入你今天准备要在几点要干的事情，它会自动匹配你的时间，并且会在指定的时间给你推送提醒，极大的改善了我遗忘症 耽误的事情</li></ol><h2 id="学习误区"><a href="#学习误区" class="headerlink" title="学习误区"></a>学习误区</h2><p>这一年来一直在追一些新的技术，有时候我就在想，真的有必要掌握那么多的知识吗。相比于 “书到用时方恨少”，我个人更倾向于 “书到用时再去读”。</p><p>有时候在学习上还是会出现 “眼高手低” 的心态。只有大处，没有小处，落不了地，眼高手低做不好事情是不行的。只有小处，没有大处，格局不够，自己做不成大事。所以，“大处着眼，小处着手” 的做事法则是最有用的，因为大处着眼，即高明。小处着眼，是精明，讲细节。看上去简单，其实是一辈子的修炼。</p><h2 id="增加新的年度计划"><a href="#增加新的年度计划" class="headerlink" title="增加新的年度计划"></a>增加新的年度计划</h2><p>2021 年岁末的时候，我给自己定了一份计划「年度一封信计划」，就是每一年岁末给我的 朋友/爱人/未来 1~3 年的自己，写一份信「pdf 格式」然后以邮件的方式发给他们，记录这一年来我和他们之间发生的比较重要的事情，对我产生的影响，对我的思考，在深思熟虑之后，我觉得，这件事值得我去做。</p><h2 id="完善了博客功能（DONE）"><a href="#完善了博客功能（DONE）" class="headerlink" title="完善了博客功能（DONE）"></a>完善了博客功能（DONE）</h2><ol><li>接入图床「PicGo + GitHub + jsDelivr」 托管至 GitHub（减少本地博客的打包体积）</li><li>接入评论 托管至 Gittalk(现已被 Valine 全面替换，原因：Gittalk 需要额外加载外网，加载缓慢)<br>方便沟通交流，避免”闭门造车”</li><li>接入统计 托管至 Baidu（了解文章阅读受众）</li><li>接入统计 字数/阅读时间（方便阅读者把控阅读文章所需时间）</li><li>自定义了 总标签云展示（方便阅读者做整体归类查看）</li><li>自定义了 主题「暗黑/亮白」切换功能（给阅读者更多的阅读体验）</li></ol><h2 id="这一年来自己觉得最重要的得与失"><a href="#这一年来自己觉得最重要的得与失" class="headerlink" title="这一年来自己觉得最重要的得与失"></a>这一年来自己觉得最重要的得与失</h2><ul><li>得：入职新团队 被分配到了一个好领导和一帮可以共事的好伙伴 学到了很多东西</li><li>失：<ol><li>更多的重心基本都放在了业务中，对社区产出的知识太少了</li><li>深度思考太少了，碎片化学习太多，缺乏系统化的学习<br>PS: 针对这种情况，我在 Notion 上重新开启了新的学习方式，将新的学习计划落实到文档中去，及时记录/查看/回顾 (部分计划罗列，如下图所示)</li></ol></li></ul><p><img src="https://cdn.jsdelivr.net/gh/alileew/alileew_images/img/20220101165125.png"></p><figcaption>notion-20220101165125.png</figcaption><h2 id="2022-年-对自己有什么样的期待"><a href="#2022-年-对自己有什么样的期待" class="headerlink" title="2022 年 对自己有什么样的期待"></a>2022 年 对自己有什么样的期待</h2><p>鉴于往年岁末的年终总结，对下一年的期待，都罗列好多条要做的事情，但真到了岁末发现都是 从入门到放弃，于是从今年开始，改变了对下一年期待的事情，不在罗列具体的事项，只罗列大致的主题内容，具体的内容项 放到自己的月度计划中去做。</p><p>希望 2022 年的自己：</p><ol><li>经营好自己的博客，多产出、多读书（每个月买一本书）</li><li>做更多有价值的东西</li><li>照顾好家人</li></ol><p>最后，用两位名人的话，赠予你我 共勉：</p><p class="article-highlight">这个世界上，只有一种真正的英雄主义，那就是认清了生活的真相后还依然热爱它。 —— 罗曼·罗兰 </p><p class="article-highlight">🔥 实际上，生活中的我们，大多数都是普通人。而普通人的成功依靠的就是坚持，拼尽全力才能轻而易举。也许你看到别人云淡风轻，但那都是披荆斩棘、努力奋斗之后的结果。没有什么毫不费力的成功，也没有横空出世的黑马，在这个等价交换的过程中，不管多努力都不为过。   —— 宋卫平 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;许久没在网络上写自己的年终总结了，上次在掘金写 “年度征文” 还是好几年前的事情。自从 2020 年将知识和笔记重点 转向了 Notion，慢慢养成了一些写作的习惯，每年的年终总结都放在了 Notion。&lt;/p&gt;
&lt;p&gt;2021 下半年搭建了&lt;a href=&quot;https:/</summary>
      
    
    
    
    
    <category term="年终总结" scheme="http://example.com/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>如何写一个shell脚本自动跑git提交代码命令</title>
    <link href="http://example.com/archives/53560/"/>
    <id>http://example.com/archives/53560/</id>
    <published>2021-12-07T13:23:56.000Z</published>
    <updated>2024-10-12T02:10:53.545Z</updated>
    
    <content type="html"><![CDATA[<p>我们日常开发过程中开发完之后，需要把自己本地的代码提交到远程仓库，一般对应的操作是：</p><pre><code class="javascript">  git add .  git commit -m &quot;feat: xxx&quot;  git push 或者 git push origin master</code></pre><p>每次做了代码改动都需要这样来提交代码，感觉成了一个工具人，于是想着 能不能通过 <code>shell</code> 脚本的方式做成一个可以自动提交代码的脚本。</p><p>初步思路是，在输入一个命令之后，输入我要提交的 <code>commit msg</code> 然后回车，直接就可以把我本地修改的代码 push 到我的远程仓库中。</p><p>于是，调研了一波shell脚本的一些使用命令之后，写了下面这个脚本<code>项目根目录下新建一个 commit.sh</code>具体代码如下：</p><pre><code class="javascript">  #! /bin/sh  git add .  read -p &quot;input commit msg: &quot; msg // 读取命令前，指定要显示的提示  git commit -m &quot;$msg&quot; // 注意此处一定要是双引号包裹  git push origin master // 你要推送的远端分支（此处是master）</code></pre><p>然后在对应的项目 <code>package.json</code> scripts 配置中，新增 commit 的运行快捷指令，具体如下：</p><pre><code class="javascript">  &quot;scripts&quot;: &#123;    &quot;commit&quot;: &quot;sh commit.sh&quot;  &#125;</code></pre><p>到这里，一个基于自动化提交代码的功能就已经完成了，具体如何使用呢？跟你日常本地打包的时候类似，如下：</p><pre><code class="javascript">  npm run commit</code></pre><p>输入此命令之后，光标会停留在<code>input commit msg: </code>后面，此时输入你要提交的 commit msg，然后直接回车就可以提交到你要push的远程仓库了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们日常开发过程中开发完之后，需要把自己本地的代码提交到远程仓库，一般对应的操作是：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;  git add .
  git commit -m &amp;quot;feat: xxx&amp;quot;
  git push</summary>
      
    
    
    
    
    <category term="git" scheme="http://example.com/tags/git/"/>
    
    <category term="shell" scheme="http://example.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>你为什么无法坚持写博客</title>
    <link href="http://example.com/archives/20132/"/>
    <id>http://example.com/archives/20132/</id>
    <published>2021-12-04T02:44:01.000Z</published>
    <updated>2024-10-12T02:10:53.544Z</updated>
    
    <content type="html"><![CDATA[<h2 id="搭建博客史"><a href="#搭建博客史" class="headerlink" title="搭建博客史"></a>搭建博客史</h2><p>说起自己的博客搭建史，也是一波三折，记得从大学毕业到现在，各种博客都折腾过一遍。</p><p>刚开始的时候是上大学的时候用wordPress模板搭建的博客，后来因为产出量不多，服务器和域名老是忘记续费，慢慢的就停了。</p><p>后来觉得平台上「掘金、简书、知乎等」直接写文章也挺好，受众多，也不用去折腾服务器、也不用担心是否会忘记续费。按照这种方式倒是坚持了一段时间，后来因为工（hai）作（shi）太（tai）忙（lan），写的文章发布到平台上的也就越来越少。</p><p>再后来，又觉得直接在 <code>GitHub</code> 的 <code>issue</code> 上写也是一种不错的方式，慢慢的就把自己的一些文章放到了 GitHub issue 上，后来也是不了了之。</p><p>最近两年，用惯了 <code>Notion「一款线上笔记软件」</code> 自己日常生活思考以及一些沉淀都放到了 Notion 上来管理，我截取了 Notion 笔记中部分片段，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/alileew/alileew_images/img/20211205175150.png"></p><figcaption>Notion笔记-20211205175150.png</figcaption><p>以及如何用 Notion 搭建自己的学习/复习计划。</p><p><img src="https://cdn.jsdelivr.net/gh/alileew/alileew_images/img/20211205175755.png"></p><figcaption>study-plan-20211205175755.png</figcaption><p>按照这种学习模式在 Notion 坚持记录了差不多2年「2020-2021」，按照每周做的事情，每月做的事情，每月定时复盘记录，所思所想，技术思考及沉淀 等等，都有罗列对应的目录进行记录跟进，觉得收获还是蛮大的。</p><h2 id="为什么要搭建博客"><a href="#为什么要搭建博客" class="headerlink" title="为什么要搭建博客"></a>为什么要搭建博客</h2><p>那么问题来了, 既然Notion云笔记这种记录方式挺好, 为什么还要搭建一个博客 <a href="https://alileew.cn/">vonmo’s blog</a> 地址呢？</p><p>我想最主要的原因：</p><p class="article-highlight">我想把我的思考以及文章分享给更多的人，💡思想的传递及碰撞💥，远比 "闭门造车" 更让人清醒。优秀的人很多，要学会接受并学习他人的优秀，也要正视自己的无知，未经省察的人生没有意义 ！</p><p>所以，2021年10月份搭建了这个博客 👉 <a href="https://alileew.cn/">vonmo’s Blog</a>, 以此记录生活、工作中的思考，技术的总结沉淀 等等。 之后将通过 <code>Notion + vonmo&#39;s blog</code> 的方式记录，Notion vonmo’s blog 对外。</p><p>之所以选择用 <a href="https://alileew.github.io/">alileew.github.io</a> 直系托管输出的方式「在github基础上又购买了vonmo.cn的域名，做了重定向」，是因为，Github自成体系，图床、评论、主页 都可以做。至于以后会不会迁移博客「无非就是折腾下搬到国内服务商」，那就是之后要做的事情了，先做好当下应该做的事，种一棵树最好的时间是十年前，其次是现在 ~ </p><p>后将 github pages 部署方式 升级至 <a href="https://vercel.com/">vercel</a> 进行发布部署，其自带https证书服务，一键发布。唯一的缺点就是国内访问的话有时候不太稳定。所以，如果<a href="https://www.vonmo.cn/">vonmo’s blog</a>访问受阻的话，欢迎通过国内<a href="https://alileew.gitee.io/">alileew.gitee.io</a>进行访问</p><p>回到此篇文章的主题 <code>你为什么无法坚持写博客</code>, 我们得先弄清楚为什么要写博客。</p><p>我听过很多人想建博客的理由是想把博客当成笔记本，记录自己学到的东西、遇到的问题和解决方法，当然这也是我前些年犯的一个问题。这是一个让博客最终走向荒废的理由，因为你在笔记本就可以做到类似的事，除非你记录的问题有你自己独到的思考，否则网友们更愿意去看 StackOverflow、掘金.</p><p>写博客的第一个意义是让陌生人通过博客了解到你是什么人、你在想什么、你做了什么。不妨试想一下，如果你正准备找工作，一位素不相识的 HR 如果要了解你，光是一份简历就能让 HR 知道你的价值吗？如果你有一个精彩的博客，HR 也许能通过你的博客了解你对技术的属于自己的思考、你在业余时间在想的事情是什么、你对待生活的态度是什么，这比简历本身更像一份立体的简历。</p><p>所以，在写博客的时候，你可以专注于：</p><ul><li>你对某个技术的看法以及思考和沉淀</li><li>你对某本书的书评，这本书给你带来了哪些巨大的思考</li><li>你职业之外的一些生活感悟和记录</li></ul><p class="article-highlight">如果你本身就不是一个爱表达的人，试图通过建立博客去培养表达欲不是一个行之有效的方法，那会更难。这就像很多本身不喜欢读书的人试图通过 Kindle 培养自己的读书习惯，大多数都是失败收场。你应该是因为喜欢读书所以买 Kindle, 正如你应该是想表达你的东西所以你写博客。</p><p>你大可不必在乎你写的文章一定要有 10W+ 的阅读量，这脱离了你写文章 记录成长的本质。你只要在乎你写的文章是经过了你的深层次思考，而阅读了你文章的陌生人，能从你的字里行间感受到你是一个对生活充满热情，对技术充满敬畏之心的人，我想这就足够了 ~ </p><p>正如 <a href="https://lutaonan.com/">Randy’s Blog</a> 中说的那样：<code>记住，一个博客的死掉不是不再更新，而是无法访问. </code> </p><h2 id="延伸链接"><a href="#延伸链接" class="headerlink" title="延伸链接"></a>延伸链接</h2><ul><li><a href="https://github.com/alileew/mywiki">前端开发相关的优秀网站、博客</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;搭建博客史&quot;&gt;&lt;a href=&quot;#搭建博客史&quot; class=&quot;headerlink&quot; title=&quot;搭建博客史&quot;&gt;&lt;/a&gt;搭建博客史&lt;/h2&gt;&lt;p&gt;说起自己的博客搭建史，也是一波三折，记得从大学毕业到现在，各种博客都折腾过一遍。&lt;/p&gt;
&lt;p&gt;刚开始的时候是上大学</summary>
      
    
    
    
    
    <category term="blog" scheme="http://example.com/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>redux / react-redux 核心属性概述</title>
    <link href="http://example.com/archives/58499/"/>
    <id>http://example.com/archives/58499/</id>
    <published>2021-11-29T13:53:44.000Z</published>
    <updated>2024-10-12T02:10:53.544Z</updated>
    
    <content type="html"><![CDATA[<h2 id="梳理此文的目的"><a href="#梳理此文的目的" class="headerlink" title="梳理此文的目的"></a>梳理此文的目的</h2><p>旨在深层次解读 redux 属性的概念、用法、注意事项等，帮助其对 redux 理解的更充分</p><h2 id="Redux是什么？"><a href="#Redux是什么？" class="headerlink" title="Redux是什么？"></a>Redux是什么？</h2><p>Redux是JavaScript状态容器，能提供可预测化的状态管理。</p><h2 id="为什么要用Redux？"><a href="#为什么要用Redux？" class="headerlink" title="为什么要用Redux？"></a>为什么要用Redux？</h2><p>前端复杂性的根本原因是大量无规律的交互和异步操作。<br>变化和异步操作的相同作用都是改变了当前View的状态，但是它们的无规律性导致了前端的复杂，而且随着代码量越来越大，我们要维护的状态也越来越多。<br>我们很容易就对这些状态何时发生、为什么发生以及怎么发生的失去控制。那么怎样才能让这些状态变化能被我们预先掌握，可以复制追踪呢？<br>这就是Redux设计的动机所在，Redux试图让每个State变化都是可预测的，将应用中所有的动作与状态都统一管理，让一切有据可循。<br><img src="https://cdn.jsdelivr.net/gh/alileew/alileew_images/img/20211130223726.png"></p><figcaption>react-20211130223726.png</figcaption>如上图所示，如果我们的页面比较复杂，又没有用任何数据层框架的话，就是图片上这个样子：交互上存在父子、子父、兄弟组件间通信，数据也存在跨层、反向的数据流。<p>这样的话，我们维护起来就会特别困难，那么我们理想的应用状态是什么样呢？看下图：<br><img src="https://cdn.jsdelivr.net/gh/alileew/alileew_images/img/20211130223822.png"></p><figcaption>react-20211130223822.png</figcaption><p>架构层面上讲，我们希望UI跟数据和逻辑分离，UI只负责渲染，业务和逻辑交由其它部分处理，从数据流向方面来说, 单向数据流确保了整个流程清晰。</p><p>我们之前的操作可以复制、追踪出来，这也是Redux的主要设计思想。</p><p>综上，Redux可以做到：</p><ol><li>每个State变化可预测。</li><li>动作与状态统一管理。</li></ol><hr><h2 id="Redux-的三大原则"><a href="#Redux-的三大原则" class="headerlink" title="Redux 的三大原则"></a>Redux 的三大原则</h2><p><img src="https://cdn.jsdelivr.net/gh/alileew/alileew_images/img/20211129222151.png"></p><figcaption>react-20211129222151.png</figcaption>认识并了解redux, 熟记这张图的执行流程就可以了。<blockquote><p>Redux 的三大原则</p><ol><li>单一数据源(Single source of truth) 整个应用的 state 被统一管理在唯一对象数store中</li><li>State 是只读的（State is read-only） state 的变化只能通过出发 action 去改变</li><li>使用纯函数来执行修改（Change are made with pure functions）使用纯函数来描述 action，这里管这种函数叫做 reducer</li></ol></blockquote><h2 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h2><p>redux 设计理念，web 应用其实是一个状态机，视图与状态是一一对应的，所有状态都保存在一个对象里面。</p><h2 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h2><p>Store 就是保存数据的地方，可以看成是一个容器，整个应用只能有一个 Store，Store 是整个 redux 的统一操作的入口。</p><h2 id="State"><a href="#State" class="headerlink" title="State"></a>State</h2><ol><li>Store 对象包含所有数据，如果想得到某个节点的数据，就要对 Store 生成快照，这种时点的数据集合，就叫做 State</li><li>当前时刻的 State，可以通过 store.getState()拿到</li><li>Redux 规定，一个 State 对应一个 View，只要 State 相同，View 就相同，你如果知道了 State，那么你就知道了 View 是什么，反之亦然。</li></ol><pre><code class="javascript">import &#123; createStore &#125; from &#39;redux&#39;;const store = createStore(fn);const state = store.getState();</code></pre><h2 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h2><ol><li>State 的变化会导致 View 层的变化，但是用户接触不到 State，只能接触到 View，所以，State 的变化必须是 View 导致的，Action 就是 View 发出的通知，表示 State 应该要发生变化了。</li><li>Action 是一个对象，type 属性是必须要的，表示 Action 的名称，其他属性自由设置。</li></ol><pre><code class="javascript">const action = &#123;  type: &quot;ADD_TODO&quot;, // Action的名称是&#39;ADD_TODO&#39;  payload: &quot;Learn Redux&quot;, // 携带的信息是字符串 &#39;Learn Redux&#39;&#125;;</code></pre><p>Action 描述当前发生的事情，改变 State 的唯一办法，就是使用 Action，它会运送数据给 Store</p><h2 id="Action-Creator"><a href="#Action-Creator" class="headerlink" title="Action Creator"></a>Action Creator</h2><p>View 要发送多少种信息，就会有多少种 Action，所以就需要定义一个函数来生成 Action，这个函数就叫<code>Action Creator</code></p><pre><code class="javascript">const ADD_TODO = &quot;TODO&quot;;// 此处的 addTodo 函数就是一个Action Creatorfunction addTodo(text) &#123;  return &#123;    type: ADD_TODO,    text,  &#125;;&#125;const action = addTodo(&quot;Learn Redux&quot;);</code></pre><h2 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h2><ol><li>Store 收到 Action 之后，必须给出一个新的 state，这样 view 才会发生变化，这种 state 的计算过程就叫 Reducer</li><li>Reducer 是一个函数，它接受 Action 和当前 State 作为参数，返回一个新的 State</li></ol><pre><code class="javascript">const reducer = function (state, action) &#123;  return new_state;&#125;;</code></pre><h2 id="Dispatch"><a href="#Dispatch" class="headerlink" title="Dispatch"></a>Dispatch</h2><ol><li><code>store.dispatch()</code> 是 View 发出 Action 的唯一方法</li></ol><pre><code class="javascript">const &#123; createStore &#125; from &#39;redux&#39;;const store = createStore(reducer);store.dispatch(&#123;  type: &#39;ADD_TYPE&#39;,  payload: &#39;Learn Redux&#39;&#125;)</code></pre><ol start="2"><li><code>store.dispatch</code> 接受一个 Action 对象作为参数，将它发送出去，结合<code>Action Creator</code> 改写后：</li></ol><pre><code class="javascript">store.dispatch(addTodo(&quot;Learn Redux&quot;));</code></pre><h2 id="Subscribe"><a href="#Subscribe" class="headerlink" title="Subscribe"></a>Subscribe</h2><p>Store 允许使用<code>store.subscribe()</code>方法设置监听函数，一旦 state 发生变化，就会自动化执行这个函数</p><pre><code class="javascript">import &#123; createStore &#125; from &quot;redux&quot;;const store = createStore(reducer);store.subscribe(listener);// store.subscribe方法返回一个函数，调用这个函数就可以接触监听let unsubscribe = store.subscribe(() =&gt; console.log(store.getState));unsubscribe();</code></pre><h2 id="Store-的一些使用方式"><a href="#Store-的一些使用方式" class="headerlink" title="Store 的一些使用方式"></a>Store 的一些使用方式</h2><pre><code class="javascript">// 构建store的两种方式import &#123; createStore &#125; from &#39;redux&#39;;// 1.不带默认参数let store = createStore(reducer)// 2. 构建带默认state的storelet store = createStore(reducer, initialState)// 构建带有中间件的sotre、applyMiddlewareimport &#123; applyMiddleware, createStore &#125; from &quot;redux&quot;import createLogger from &#39;redux-logger&#39;; // 日志中间件const store = createStore(&#123;  reducer,  initial_state,  applyMiddleware(createLogger)&#125;);// 还可以构建带多个中间件的storeconst store = createStore(&#123;  reducer,  applyMiddleware(thunk, promise, logger)&#125;)</code></pre><h2 id="Store-的方法"><a href="#Store-的方法" class="headerlink" title="Store 的方法"></a>Store 的方法</h2><ol><li><code>store.getState()</code> 获取整个状态数据对象</li><li><code>store.dispatch()</code> 分发 Action</li><li><code>store.subscribe()</code> 订阅状态数据的变化</li></ol><pre><code class="javascript">import &#123; createStore &#125; from &quot;redux&quot;;let &#123; subscribe, dispatch, getState &#125; = createStore(reducer);</code></pre><h2 id="createStore"><a href="#createStore" class="headerlink" title="createStore"></a>createStore</h2><p>redux 提供 createStore 这个函数, 用来生成 Store</p><pre><code class="javascript">import &#123; createStore &#125; from &quot;redux&quot;;const store = createStore(fn);</code></pre><p>createStore 函数接受另一个函数作为参数，返回新生成的 Store 对象<br>注：fn 是一个函数，但一般是 reducer</p><h2 id="redux-thunk"><a href="#redux-thunk" class="headerlink" title="redux thunk"></a>redux thunk</h2><p><a href="https://github.com/reduxjs/redux-thunk">redux-thunk</a> 中间件改造了 redux 的 dispatch 方法允许我们用<code>store.dispatch(fn)</code>,fn 可以是一个函数。而且此函数可以接受两个参数：<code>dispatch、getState</code>做为参数。</p><pre><code class="javascript">import &#123; createStore &#125; from &#39;redux&#39;;const store = &#123;  reducer,  applyMiddleware(thunk)&#125;</code></pre><h2 id="applyMiddleWare"><a href="#applyMiddleWare" class="headerlink" title="applyMiddleWare"></a>applyMiddleWare</h2><p>Redux 中间件将会在 action 被分发之后、到达 reducer 之前执行，对应到工作流中，它的执行时机<br><code>action ⇒ middleWare ⇒ dispatch ⇒ reducer ⇒ nextState</code></p><pre><code class="javascript">// 若有多个中间件，那么 Redux 会结合它们被“安装”的先后顺序，依序调用这些中间件，这个过程如下所示：action  ⇒  middleWare1    ⇒  middleWare2      ⇒  middleWare3        ⇒  dispatch          ⇒ reducer            ⇒ nextState</code></pre><p>中间件是对 dispatch 的扩展，或者说重写，增强 dispatch 的功能！<br>applyMiddleWare 是 redux 的原生方法, applyMiddlewares 作用是将所有中间件组成一个函数，源码解读如下（具体看注释的地方）：</p><pre><code class="javascript">import compose from &quot;./compose&quot;;/** * 传入的参数是原始的dispatch方法，返回的结果是改造后的dispatch方法 * 通过compose，可以让多个改造函数抽象成一个改造函数 */export default function applyMiddleware(...middlewares) &#123;  // 返回一个函数A，函数A的参数是一个createStore函数  // 函数A的返回值是函数B，其实也就是一个加强后的createStore函数，大括号内的是函数B的函数体  return (createStore) =&gt; (...args) =&gt; &#123;    // 用参数传递进来的的createStore创建一个store    // 用来获取dispatch和getState    const store = createStore(...args);    // 改造的只是store中的dispatch方法    let dispatch = () =&gt; &#123;      // 此dispatch的作用是改造完成前调用dispatch打印错误信息      throw new Error(        `Dispatching while constructing your middleware is not allowed. ` +          `Other middleware would not be applied to this dispatch.`      );    &#125;;    // 将每个中间件与我们的state关联起来（通过传入getState方法）得到改造后的函数    const middlewareAPI = &#123;      getState: store.getState,      dispatch: (...args) =&gt; dispatch(...args),    &#125;;    // middlewares是一个中间件函数数组，中间件函数的返回值是一个改造dispatch的函数    // 调用数组中的每个中间函数，得到所有的改造函数    const chain = middlewares.map((middleware) =&gt; middleware(middlewareAPI));    // 将这些改造后的函数通过compose库整合成一个函数    // 用compose后的函数去改造store的dispatch    dispatch = compose(...chain)(store.dispatch);    /**     * compose方法作用     * compose(func1,func2,func3)     * 返回一个函数(...args) =&gt;  func1(fun2(fun3(...args)))     * 即传入的dispatch函数被func3改造后得到一个新的dispatch函数然后继续被fun2改造....     * 其实就是函数柯里化的连续调用     */    //  返回store, 用改造后的dispatch方法替换store中的dispatch    return &#123;      ...store,      dispatch,    &#125;;  &#125;;&#125;</code></pre><blockquote><p>Redux 中间件的工作模式，你需要牢牢把握以下两点:</p><ol><li> 中间件执行的时机，即 action 被分发之后，reducer 被触发之前</li><li> 中间件执行的前提，即 applyMiddleWare 将会对 dispatch 进行改写，使得 dispatch 在触发 reducer 之前，会首先执行对 Redux 中间件的链式调用</li></ol></blockquote><hr><h2 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h2><p>相比 redux, react-redux 需要掌握额外的 api，遵守它的组件拆分规范</p><blockquote><p>react-redux 将组件拆分成两大类：</p><ol><li>UI 组件（presentational component）<br> a. 只负责UI呈现（纯组件），不负责业务逻辑<br> b. 无状态，所有数据都由 this.props 提供<br> c. 不适用redux的api</li><li>容器组件（container component）<br> a. 只负责管理数据/逻辑，不负责UI呈现<br> b. 带有内部状态<br> c. UI组件负责UI的呈现，容器组件负责管理数据和逻辑</li></ol></blockquote><h2 id="react-redux-的规定"><a href="#react-redux-的规定" class="headerlink" title="react-redux 的规定"></a>react-redux 的规定</h2><ol><li>所有的 UI 组件都应该由用户提供</li><li>容器组件则是由<code>react-redux</code>自动生成，也就是说，用户负责视觉层，状态管理全部交给它</li></ol><p>connect()连接容器组件和 UI 组件</p><ol><li>说回 connect(),其实它就是地地道道的高级组件（HOC）高级组件的用法，可自行补习功课 <a href="https://reactjs.org/docs/higher-order-components.html">higher-order-components</a></li></ol><pre><code class="javascript">// 源码中，connect 结构，传了四个入参function connect(mapStateToProps?, mapDispatchToProps?, mergeProps?, options?) &#123;    ....&#125;</code></pre><pre><code class="javascript">// 使用示例如下：// TodoList是 UI 组件，VisibleTodoList就是由 React-Redux 通过connect方法自动生成的容器组件import &#123; connect &#125; from &quot;react-redux&quot;;const VisibleTodoList = connect()(TodoList);</code></pre><p>如果需要定义业务逻辑, 毫无疑问的需要输入/输出逻辑</p><ol><li>输入逻辑, 外部的数据(即 state 对象)如何转换为 UI 组件参数</li><li>输出逻辑, 用户发出的动作如何变为 Action 对象, 从 UI 组件传出去</li></ol><pre><code class="javascript">const VisibleTodoList = connect(mapStateToProps, mapDispatchToProps)(TodoList);</code></pre><ol><li>mapStateToProps 输入逻辑, mapStateToProps 是一个函数。它的作用就是像它的名字那样，建立一个从（外部的）state 对象到（UI 组件的）props 对象的映射关系。</li><li>作为函数, mapStateToProps 执行后应该返回一个对象, 里面的每一个键值对就是一个映射。</li></ol><pre><code class="javascript">const mapStateToProps = (state) =&gt; &#123;  return &#123;    // getVisibleTodos 只是一个自定义的函数而已，重点关注里面值的传递及获取方式    todos: getVisibleTodos(state.todos, state.visibilityFilter),  &#125;;&#125;;</code></pre><p>mapStateToProps 会订阅 Store，每当 state 更新的时候，就会自动执行，重新计算 UI 组件的参数，从而触发 UI 组件的重新渲染。</p><ol><li>第一个参数总是 state 对象，它是 redux 中存储的顶层数据。还可以使用第二参数, 代表容器组件的 props 对象，对象内的字段就是该组件需要从 store 中获取的值。<pre><code class="javascript">const mapStateToProps = (state, ownProps) =&gt; &#123; return &#123;   active: oweProps.filter === state.visibilityFilter, &#125;;&#125;;</code></pre></li><li>如果容器组件参数发生变化, 也会引发 UI 组件重新渲染</li><li>connect 方法可以省略 mapStateToProps 参数，那样的话，UI 组件就不会订阅 Store，就是说 Store 的更新不会引起 UI 组件的更新。</li></ol><p><strong>mapStateToProps 输出逻辑, 将用户对 UI 组件的操作映射成 Action</strong><br>用来建立 UI 组件的参数到 store.dispatch 方法的映射, 也就是说, 它定义了哪些用户的操作应该当作 Action, 传给 store，可以是一个函数也可以是一个对象。</p><p>mapDispatchToProps 用于建立组件和 store.dispatch 的映射关系。它可以是一个对象，也可以是一个函数，当它是一个函数的时候，第一个参数就是 dispatch，第二个参数是组件自身的 props。</p><pre><code class="javascript">// mapDispatchToProps的对象形式如下：const mapDispatchToProps = &#123;  AddAction() &#123;    return (dispatch) =&gt;      dispatch(&#123;        type: ADD,      &#125;);  &#125;,&#125;;</code></pre><hr><h2 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h2><p><code>react-redux</code>提供Provider组件，可以让容器组件拿到state</p><pre><code class="javascript">import &#123; createStore &#125; from &#39;redux&#39;;import &#123; Provider &#125; from &#39;react-redux&#39;const store = createStore(reducer)render(  &lt;Provider store=&#123;store&#125;&gt;    &lt;App /&gt;  &lt;/Provider&gt;,  document.getElementById(&quot;root&quot;))</code></pre><p>上例，Provider在根组件外面包了一层，这样App的所有子组件都可以拿到state的值了。</p><p>到这里，redux / react-redux 涉及到的一些核心属性基本解读完毕，希望通过本篇文章的解读，对你了解redux又有新的认识。</p><hr><p>文章参考：</p><ol><li><a href="https://tech.meituan.com/2017/07/14/redux-design-code.html">Redux从设计到源码</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;梳理此文的目的&quot;&gt;&lt;a href=&quot;#梳理此文的目的&quot; class=&quot;headerlink&quot; title=&quot;梳理此文的目的&quot;&gt;&lt;/a&gt;梳理此文的目的&lt;/h2&gt;&lt;p&gt;旨在深层次解读 redux 属性的概念、用法、注意事项等，帮助其对 redux 理解的更充分&lt;/p&gt;</summary>
      
    
    
    
    
    <category term="react" scheme="http://example.com/tags/react/"/>
    
    <category term="redux" scheme="http://example.com/tags/redux/"/>
    
    <category term="react-redux" scheme="http://example.com/tags/react-redux/"/>
    
  </entry>
  
  <entry>
    <title>git高级命令: reset/merge/rebase 图形化手把手教学</title>
    <link href="http://example.com/archives/62141/"/>
    <id>http://example.com/archives/62141/</id>
    <published>2021-11-27T03:03:55.000Z</published>
    <updated>2024-10-12T02:10:53.543Z</updated>
    
    <content type="html"><![CDATA[<h2 id="git-常用命令速查表"><a href="#git-常用命令速查表" class="headerlink" title="git 常用命令速查表"></a>git 常用命令速查表</h2><p><img src="https://cdn.jsdelivr.net/gh/alileew/alileew_images/img/601637982348.jpg"></p><figcaption>git-601637982348.png</figcaption><p>上篇文章 <a href="/archives/8032/">git 基本操作，一篇文章就够了</a>，介绍了日常使用 git 的一些操作，接下来介绍下 git 的一些高级用法，提升你对 git 新的认识。</p><h2 id="消除最近的几次提交"><a href="#消除最近的几次提交" class="headerlink" title="消除最近的几次提交"></a>消除最近的几次提交</h2><p>已经 push 的代码，有些 commit 确确实实是不想要的，暂存区和工作区都恢复成你指定的那个 commit 的内容了 如图所示，我需要将代码恢复到 <code>cbb25868ec9ef</code> 这个 commit 所在的位置。<br><img src="https://cdn.jsdelivr.net/gh/alileew/alileew_images/img/20211127111935.png"></p><figcaption>git-20211127111935.png</figcaption><pre><code class="javascript">// 执行回退指令git reset --hard cbb25868ec9ef</code></pre><p>reset 执行成功之后， <code>git log --graph</code> 查看提交记录。<br><img src="https://cdn.jsdelivr.net/gh/alileew/alileew_images/img/20211127112216.png"></p><figcaption>git-20211127112216.png</figcaption>这样就可以删掉之前的提交，将其恢复到你当前执行的 commit hash 那个位置。因为此命令具有不可恢复性，所以在执行此条命令前，请确定你之前的提交是确确实实不想要的。<blockquote><ol><li>git revert 是用一次新的 commit 来回滚之前的 commit，git reset 是直接删除指定的 commit。</li><li>git reset 是把 HEAD 向后移动了一下，而 git revert 是 HEAD 继续前进，只是新的 commit 的内容和要 revert 的内容正好相反，能够抵消要被 revert 的内容。</li></ol></blockquote><hr><h2 id="提交暂存区后如何查看-diff"><a href="#提交暂存区后如何查看-diff" class="headerlink" title="提交暂存区后如何查看 diff"></a>提交暂存区后如何查看 diff</h2><p>diff 暂存区 也就是 git add . 后，还想查看 diff, 执行<code>git diff --cached</code> 后面可以跟具体要 diff 的文件，不写就默认 diff 的是所有在暂存区的文件。<br>比较不同分支，不同文件的差异，如何用命令行进行操作查看呢？</p><pre><code class="javascript">// 比如 我们想对比 main 和 temp 分支的所有改动文件的diff差异git diff main temp// 如果只想对比其中的某个文件 在不同分支上的diff差异, 后面根据题的文件名就可以了git diff main temp -- index.html</code></pre><hr><h2 id="修改最新-commit-的-message"><a href="#修改最新-commit-的-message" class="headerlink" title="修改最新 commit 的 message"></a>修改最新 commit 的 message</h2><pre><code class="javascript">git commit --amend</code></pre><hr><h2 id="修改老旧-commit-的-message"><a href="#修改老旧-commit-的-message" class="headerlink" title="修改老旧 commit 的 message"></a>修改老旧 commit 的 message</h2><p><img src="https://cdn.jsdelivr.net/gh/alileew/alileew_images/img/20211127112913.png"></p><figcaption>git-20211127112913.png</figcaption><pre><code class="javascript">// 就要用到变基操作，既然是变基，就要找到当前你需要更改message的父级提交git rebase -i cbb25868</code></pre><p>此时会有一个交互的信息出来，如下图:<br><img src="https://cdn.jsdelivr.net/gh/alileew/alileew_images/img/20211127113123.png"></p><figcaption>git-20211127113123.png</figcaption>此时根据提示，执行 `Commands`相应的操作，这里可以在第一个 `pick a4f74a5 refactor: edit text`<p>中更改第一个 <code>pick</code> 为 <code>r 或 reword</code> 即 <code>r a4f74a5 refactor: edit text</code>，然后保存退出。退出后，又将进入到具体你更改的那个 commit message 中.</p><p><img src="https://cdn.jsdelivr.net/gh/alileew/alileew_images/img/20211127113326.png"></p><figcaption>git-20211127113326.png</figcaption><p>这个时候 重新修改你的 message 信息，然后保存退出就可以了，退出后，此时就会告知你修改已经成功了。</p><p>【detached HEAD commitHash】分离头指针，步骤：git 会先分离头指针，然后在上面做调整，调整完毕之后，他还把最新的 commit 产生之后呢，又用一个指针指向他，也就是我们当前工作的这个 main 分支。<br><img src="https://cdn.jsdelivr.net/gh/alileew/alileew_images/img/20211127113406.png"></p><figcaption>git-20211127113406.png</figcaption><p>对比下修改前后的区别：<br><img src="https://cdn.jsdelivr.net/gh/alileew/alileew_images/img/20211127113553.png"></p><figcaption>git-20211127113553.png</figcaption><hr><h2 id="把连续多个-commit-整理成1个"><a href="#把连续多个-commit-整理成1个" class="headerlink" title="把连续多个 commit 整理成1个"></a>把连续多个 commit 整理成1个</h2><p>前提是：此分支尚未推送至远程，只修该提交记录，对提交文件内容不做修改。<br>找到操作提交记录的父提交 commitId(如：<code>cbb25868ec</code> ，也可以理解为上一次提交记录 <code>git rebase -i cbb25868ec</code><br>1、找到像合并的那几个提交信息<br>2、想合并的几次提交前面的 pick 保留一个，其余想合并的提交将 pick 更新为 s，然后在 git 弹出的命令窗口中，添加修改提交记录信息，最后保存退出即可</p><p>比如 我当前的 commit 记录中 这里的这两个记录都是关于编辑修改文字相关的提交<br><img src="https://cdn.jsdelivr.net/gh/alileew/alileew_images/img/20211127113920.png"></p><figcaption>git-20211127113920.png</figcaption><pre><code class="javascript">git rebase -i cbb25868ec</code></pre><p><img src="https://cdn.jsdelivr.net/gh/alileew/alileew_images/img/20211127164246.png"></p><figcaption>git-20211127164246.png</figcaption><p><img src="https://cdn.jsdelivr.net/gh/alileew/alileew_images/img/20211127164024.png"></p><figcaption>git-20211127164024.png</figcaption><p>保持第一个前一个为 pick, 后面想要合并的 commit 使用 <code>s 或者 squash</code> 这样，就会把所有 <code>s</code> 标记的 commit 都合并到前一个第一个以 <code>pick</code> 开头的 commit。<br>上图 <code>:wq!</code> 保存退出后，进入到 commit 信息修改页面，对你需要合并后的 commit 编写具体的文案即可。<br><img src="https://cdn.jsdelivr.net/gh/alileew/alileew_images/img/20211127164422.png"></p><figcaption>git-20211127164422.png</figcaption><p><img src="https://cdn.jsdelivr.net/gh/alileew/alileew_images/img/20211127164503.png"></p><figcaption>git-20211127164503.png</figcaption><p>执行 <code>git log --graph</code> 前后对比。<br><img src="https://cdn.jsdelivr.net/gh/alileew/alileew_images/img/20211127164653.png"></p><figcaption>git-20211127164653.png</figcaption>这个时候，连续的多个 commit 整理成 1 个 commit 就完成了。你可以会有疑惑 如果是不连续的呢，那接下来，我们尝试操作下不连续的。<hr><h2 id="把间隔几个-commit-整理成1个"><a href="#把间隔几个-commit-整理成1个" class="headerlink" title="把间隔几个 commit 整理成1个"></a>把间隔几个 commit 整理成1个</h2><p>如何将 <code>间隔的几个commit整理成一个</code>的操作其实和 <code>连续的多个commit整理成1个</code> 操作其实差不多，只是在 rebase 交互的时候，移动其位置就可以了，话不多说，直接上代码。<br><img src="https://cdn.jsdelivr.net/gh/alileew/alileew_images/img/20211127164955.png"></p><figcaption>git-20211127164955.png</figcaption>这里我新提交了三个 commit，对应下图红色框框中的部分，其中橙色框框中的部分为同一类修改，但是不是连续的，我想将这两个合并成一个 commit。<pre><code class="javascript">// 先找到操作提交记录的父提交为依据，这里以feat:create http server提交为依据，commitId 为 cbb25868git rebase -i cbb25868</code></pre><p><img src="https://cdn.jsdelivr.net/gh/alileew/alileew_images/img/20211127165058.png"></p><figcaption>git-20211127165058.png</figcaption><p>调整 commit 的位置，老样子，需要被合并的 commitId 用 <code>s 或 squash</code> </p><p><img src="https://cdn.jsdelivr.net/gh/alileew/alileew_images/img/20211127165135.png"></p><figcaption>git-20211127165135.png</figcaption><p>保存退出之后，可能会出现下面两种情况中的一种：</p><ol><li>如果没有直接进入到交互页面，而是直接退出了。执行 <code>git status</code> 之后，查看提示,<br>然后继续 <code>git rebase --continue</code> 执行此命令，就会继续进入到交互页面了。</li><li>如果没有直接退出，就会直接弹下面的 <code>message</code> 修改交互页面，直接做相应的修改就可以。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/alileew/alileew_images/img/20211127165217.png"></p><figcaption>git-20211127165217.png</figcaption><p>修改完之后，保存退出 出现 successfully 就说明修改成功了。</p><p><img src="https://cdn.jsdelivr.net/gh/alileew/alileew_images/img/20211127165250.png"></p><figcaption>git-20211127165250.png</figcaption><p>接下来 我们执行 <code>git log --graph</code> 再来看看合并后的 commit 的前后变化</p><p><img src="https://cdn.jsdelivr.net/gh/alileew/alileew_images/img/20211127165413.png"></p><figcaption>git-20211127165413.png</figcaption><p>这个时候，我们就把间隔的几个 commit 整理成 1 个了。</p><hr><h2 id="将某分支合并到另外一个分支"><a href="#将某分支合并到另外一个分支" class="headerlink" title="将某分支合并到另外一个分支"></a>将某分支合并到另外一个分支</h2><p>将一个分支的更改合并到另外一个分支中（一般是主分支同步更新到自己开发分支）<br>背景描述： main 分支是主分支，temp 和 test 是子分支，基于 main 分支</p><p>通常情况下，我们使用的是 merge 的操作：<br>git:(temp) &gt; git merge main 此时，main 分支的代码将会被合并到 temp 分支（前提是 先要切换到 main 分支拉取最新的代码），这种方式的缺点有两个：</p><ol><li>必须要切换到主分支拉取最新的代码，在切回自己的分支进行 merge</li><li>合并后的所有 commit 会按照提交时间从旧到新排列</li><li>git 流程 会被打乱，直接上图</li></ol><p><img src="https://cdn.jsdelivr.net/gh/alileew/alileew_images/img/20211127165804.png"></p><figcaption>git-20211127165804.png</figcaption><p>其次，还可以采用 rebase 的操作：<br>test 分支做了代码文件内容更改，合并到了 main 分支，此时我 temp 分支是落后于 main 分支的，此时我需要将远程主分支 main 的代码同步到 temp 分支。<br>主要命令：<code>git pull origin main --rebase</code> 此时 main 分支上最新的代码就全部被合并到 temp 分支上了</p><p><img src="https://cdn.jsdelivr.net/gh/alileew/alileew_images/img/20211127165922.png"></p><figcaption>git-20211127165922.png</figcaption><p>使用 rebase 的优点有：</p><ol><li>改变当前分支从 master 上拉出分支的位置</li><li>没有多余的合并历史的记录，且合并后的 commit 顺序不一定按照 commit 的提交时间排列</li><li>可能会多次解决同一个地方的冲突（有 squash 来解决）</li><li>更清爽一些，master 分支上每个 commit 点都是相对独立完整的功能单元</li></ol><p><img src="https://cdn.jsdelivr.net/gh/alileew/alileew_images/img/20211127170023.png"></p><figcaption>git-20211127170023.png</figcaption><blockquote><p>那么 rebase 到底做了什么操作呢？<br>首先，git 会把 feature 分支里面的每个 commit 取消掉；<br>其次，把上面的操作临时保存成 patch 文件，存在 .git/rebase 目录下；<br>然后，把 feature 分支更新到最新的 master 分支；<br>最后，把上面保存的 patch 文件应用到 feature 分支上；</p></blockquote><p><code>git-rebase</code> 存在的价值是：对一个分支做<code>「变基」</code>操作。 1.当我们在一个过时的分支上面开发的时候，执行 rebase 以此同步 master 分支最新变动； 2.假如我们要启动一个放置了很久的并行工作，现在有时间来继续这件事情，很显然这个分支已经落后了。这时候需要在最新的基准上面开始工作，所以 rebase 是最合适的选择</p><hr><h2 id="解决-rebase-过程中的冲突"><a href="#解决-rebase-过程中的冲突" class="headerlink" title="解决 rebase 过程中的冲突"></a>解决 rebase 过程中的冲突</h2><p>关于冲突解决这块，使用以下几种方式处理这些冲突：</p><pre><code class="javascript">1. git rebase --abort （表示放弃之前的rebase）  a. 会放弃合并，回到rebase操作之前的状态，之前的提交的不会丢弃；  b. 执行之后，本地内容会回到提交之间的状态，也就是回到以前提交但没有pull是的状态，简单来说就是撤销rebase。2. git rebase --skip （就是跳过这个rebase）  a. 则会将引起冲突的commits丢弃掉（使用skip时请慎重、慎用！！）；3. git rebase --continue （就是继续rebase）  a. 执行完 git pull --rebase 之后，如果有冲突，先是解决当前的页面的冲突  b. 然后git add . --&gt; git rebase --continue 如果再有，再解决，持续执行git add . --&gt; git rebase --continue4. 解决完冲突之后，控制台会一直提醒 git pull 不用去理会，一波强推 git push -f 就完事了</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;git-常用命令速查表&quot;&gt;&lt;a href=&quot;#git-常用命令速查表&quot; class=&quot;headerlink&quot; title=&quot;git 常用命令速查表&quot;&gt;&lt;/a&gt;git 常用命令速查表&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net</summary>
      
    
    
    
    
    <category term="git" scheme="http://example.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>oh-my-zsh + autosuggestion 提升git命令操作体验</title>
    <link href="http://example.com/archives/37989/"/>
    <id>http://example.com/archives/37989/</id>
    <published>2021-10-27T02:23:01.000Z</published>
    <updated>2024-10-12T02:10:53.543Z</updated>
    
    <content type="html"><![CDATA[<h2 id="oh-my-zsh-zsh-autosuggestion-配置"><a href="#oh-my-zsh-zsh-autosuggestion-配置" class="headerlink" title="oh-my-zsh + zsh-autosuggestion 配置"></a>oh-my-zsh + zsh-autosuggestion 配置</h2><p>配置完之后，终端会记录你前一次的命令操作，为你提供 预览 + 自动补全的功能，如图：<br><img src="https://cdn.jsdelivr.net/gh/alileew/alileew_images/img/20211127102913.png"></p><figcaption>git-20211127102913.png</figcaption>灰色是给你的提示，此时你只需要按一下：➡️ 箭头，就可以补全当前的整条命令，为你的开发提升更高的效率。<hr><p>配置步骤如下（目前仅针对 mac）：</p><ol><li>安装 zsh：</li></ol><pre><code class="javascript">sh -c &quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;</code></pre><ol start="2"><li>安装 autosuggestions：</li></ol><pre><code class="javascript">git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions</code></pre><ol start="3"><li>进入 zshrc 配置页</li></ol><pre><code class="javascript">vi ~/.zshrc</code></pre><p>找到如图所示的位置，添加 autosuggestions 的<br><img src="https://cdn.jsdelivr.net/gh/alileew/alileew_images/img/591637979914.jpg"></p><figcaption>git-591637979914.jpg</figcaption><ol start="4"><li>重启终端，开始你的终端之旅吧，相信我，你会爱上 TA</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;oh-my-zsh-zsh-autosuggestion-配置&quot;&gt;&lt;a href=&quot;#oh-my-zsh-zsh-autosuggestion-配置&quot; class=&quot;headerlink&quot; title=&quot;oh-my-zsh + zsh-autosuggestion</summary>
      
    
    
    
    
    <category term="git" scheme="http://example.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>git基本操作，一篇文章就够了</title>
    <link href="http://example.com/archives/8032/"/>
    <id>http://example.com/archives/8032/</id>
    <published>2021-10-10T14:27:56.000Z</published>
    <updated>2024-10-12T02:10:53.543Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常识区"><a href="#常识区" class="headerlink" title="常识区"></a>常识区</h2><pre><code class="javascript">  git add . // 更新到暂存区  git commit -m &quot;feat: 添加 Hello.ts 页面&quot; // 更新到资源库    // 提交规范:    1. feat: 增加新功能    2. fix: 修复bug    3. docs: 只改动了文档相关内容    4. styles: 不影响代码的含义的改动，如：去掉空格、缩进、增删分号等    5. build: 构造工具或者外部依赖的改动 如webpack、npm等    6: refactor: 代码重构时作用  git commit --amend // vim中修改内容信息  git push // 提交至远程仓库  git branch -D &lt;BranchName&gt; // 删除本地分支    git push origin --delete &lt;BranchName&gt;  // 真正的删除远程分支</code></pre><h2 id="重点区"><a href="#重点区" class="headerlink" title="重点区"></a>重点区</h2><pre><code class="javascript">  [git reset &amp; git revet]  1. git如何撤销上一次commit操作 ???  // 最后一次提交的修改，包括本地文件的修改都会被清除，彻底还原到上一次提交的状态且无法找回。  // 所以在执行reset --hard之前一定要小心  `git reset --hard HEAD~` 或者指定回退提交的commidHash `git reset --hard &lt;commitHash&gt;`  // 重置HEAD到指定的版本, 不会修改index和working tree  `git reset --soft &lt;commitHash&gt;`    git reset (--mixed) HEAD~1     回退一个版本,且会将暂存区的内容和本地已提交的内容全部恢复到未暂存的状态,不影响原来本地文件(未提交的也 不受影响) 回退后的代码（已提交的内容）放在工作区，工作区和暂存区的修改都会留下    git reset --soft HEAD~1     回退一个版本,不清空暂存区,将已提交的内容恢复到暂存区,不影响原来本地的文件(未提交的也不受影响)     将已提交的内容恢复到暂存区，原来暂存区和工作区的内容仍然保留    git reset --hard HEAD~1     回退一个版本,清空暂存区,将已提交的内容的版本恢复到本地,本地的文件也将被恢复的版本替换    已提交的内容恢复到工作区，原来工作区中的修改会留下，原来暂存区中的内容会消失  --mixed  会保留源码,只是将git commit和index 信息回退到了某个版本.  --soft   保留源码,只回退到commit信息到某个版本.不涉及index的回退,如果还需要提交,直接commit即可.  --hard   源码也会回退到某个版本,commit和index 都会回退到某个版本.(注意,这种方式是改变本地代码仓库源码)  2. commit push 代码已经更新到远程仓库 如何撤销 ？？？  // revert 之后你的本地代码会回滚到指定的历史版本,这时你再 git push 既可以把线上的代码更新  `git revert &lt;commit_id&gt;`  // 注意：git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit，看似达到的效果是一样的,其实完全不同。</code></pre><pre><code class="javascript">  [git stash]  // 全部未保存的代码添加到储藏  git stash 或 git stash save &quot;message&quot;    1. git stash pop // 应用第一个储藏并删除，如果pop对应项，则直接pop后面跟对应的序列号就可以    2. git stash apply // 应用第一个储藏但依然保留在列表项中。    3. git stash list // 查看stash列表    4. git stash drop stash@&#123;xxx&#125; // 删除某项储藏    5. git stash clear // 删除所有储藏的stash</code></pre><pre><code class="javascript">  [git cherry-pick]  // 将指定的提交（commit）应用于其他分支。  git cherry-pick &lt;commitHash&gt;   a - b - c - d   Master         \           e - f - g Feature  现在将提交 f 应用到 master 分支。，切换到 master 分支 `git checkout master` 然后执行 `git cherry-pick f`   a - b - c - d - f   Master       \         e - f - g Feature小知识：  1. git cherry-pick 命令的参数，不一定是提交的哈希值，分支名也是可以的，表示转移该分支的最新提交     &gt; git cherry-pick feature // feature分支的最近一次提交，转移到当前分支。  2. 如果需要同时 cherry-pick多个 &lt;commitHash&gt;    &gt; git cherry-pick &lt;commitHash1&gt; &lt;commitHash2&gt;  3. 想要在不同分支间 高效的使用 cherry-pick，提交代码的细粒度必须要小，且每次提交的功能点尽量单一     如：功能点都是可复用的业务逻辑，才能更好的高效复用。</code></pre><pre><code class="javascript">  [git rebase]  git stash // 贮藏本地代码  git pull origin latest --rebase // 拉取远程latest分支代码  git stash pop // 还原本地贮藏代码</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;常识区&quot;&gt;&lt;a href=&quot;#常识区&quot; class=&quot;headerlink&quot; title=&quot;常识区&quot;&gt;&lt;/a&gt;常识区&lt;/h2&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;  git add . // 更新到暂存区
  git commit -m &amp;</summary>
      
    
    
    
    
    <category term="git" scheme="http://example.com/tags/git/"/>
    
  </entry>
  
</feed>
